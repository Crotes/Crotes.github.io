<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>树 | Crotes</title><meta name="keywords" content="ACM"><meta name="author" content="Crotes"><meta name="copyright" content="Crotes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="此文章是在学习过程中学习的树和类树">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="http://crotes.top/2021/04/15/%E6%A0%91/index.html">
<meta property="og:site_name" content="Crotes">
<meta property="og:description" content="此文章是在学习过程中学习的树和类树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png">
<meta property="article:published_time" content="2021-04-15T08:28:09.000Z">
<meta property="article:modified_time" content="2022-04-04T08:57:03.920Z">
<meta property="article:author" content="Crotes">
<meta property="article:tag" content="ACM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png"><link rel="shortcut icon" href="https://npm.elemecdn.com/crotes-blog@1.0.2/blogimg/facivion.png"><link rel="canonical" href="http://crotes.top/2021/04/15/%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-04 08:57:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script async src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://npm.elemecdn.com/crotes-blog@1.0.2/blogimg/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://cuit-wiki.crotes.top"><i class="fa-fw fas fa-book"></i><span> Cuit-Wiki</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Crotes</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://cuit-wiki.crotes.top"><i class="fa-fw fas fa-book"></i><span> Cuit-Wiki</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-15T08:28:09.000Z" title="发表于 2021-04-15 08:28:09">2021-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-04T08:57:03.920Z" title="更新于 2022-04-04 08:57:03">2022-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ACM/">ACM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="树状数组-优雅的前缀和"><a href="#树状数组-优雅的前缀和" class="headerlink" title="树状数组-优雅的前缀和"></a>树状数组-优雅的前缀和</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>树状数组中的节点储存的是一定范围之内的和</strong> ，其中节点范围可以参考下面这个图片。绿色为树状数组的节点，黄色为数组的节点。</p>
<p>在使用平常方法时，如果需要频繁查询某个区间的和，那么一般情况下是直接循环累加或者使用前缀和。但是如果数字可以修改呢，例如数字的修改，新增，此时不仅仅要修改数字，还要修改前缀和数组，此时复杂度为<code>O(n)</code>。但是如果利用树状数组，那么我们就不需要全部修改后面所有的数组，只需要修改部分就可以了，树状数组修改的复杂度为<code>O(log n)</code>。</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/bit/bit1.png" alt="bit1"></p>
<h2 id="详细知识"><a href="#详细知识" class="headerlink" title="详细知识"></a>详细知识</h2><p>树状数组储存的区间范围为以当前下标开始，向左推移 <strong>最后一个1与后面所有的0</strong> 所有的范围。</p>
<p>用一个例子来解释：</p>
<p>比如上面树状数组的节点<code>T[6]</code>，6转化为2进制为<code>(0110)</code>，那么 <strong>最后一个1与后面所有的0</strong> 为(10)转化为10进制为2，那么<code>T[6]</code>所储存的便是<code>A[6]</code>与<code>A[5]</code>的和；同理T[8]储存的是<code>A[1]</code>到<code>A[8]</code>的和。</p>
<p>利用这个方法，如果想知道<code>A[1]-A[7]</code>的和，那么我们只需要知道<code>T[7]</code>,<code>T[6]</code>,<code>T[4]</code>即可，因为他们分别储存了<code>A[7]</code>, <code>A[6]-A[5]</code>,<code>A[4]-A[1]</code>的和。注意，<code>7(0111)</code>拆掉最后一个1之后为<code>6(0110)</code>，再拆掉最后一个1为<code>4(0100)</code>，再拆就为<code>0(0000)</code>了。</p>
<p>可以发现，如果我们想知道A的前缀和sum[k]，那么我们只需要将这个k每次拆掉最后一个1，然后在树状数组中去寻找T[k]累加即可。时间复杂度为<code>O(log n)</code>。</p>
<p>如果想要修改某个数字，那么我们只需要知道哪些节点储存了当前节点的值即可。观察上图，反过来加即可。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>那么就涉及到一个问题，怎么才能快速的把7拆开呢。那么就要引入 <strong>lowbit函数</strong> ， <strong>lowbit函数</strong> 的产生其实与树状数组没有太大的关系，但是他可以高效的解决树状数组的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要理解 <strong>lowbit</strong> ，那么需要先知道数字是怎么用二进制来存储的。正数不用说，重要的是负数。</p>
<p>负数在计算机中是用补码来储存的，补码为正数所对应的二进制 <strong>取反后加一</strong> 。</p>
<p>例如<code>-1</code>，他是由<code>1(0001)</code>取反后<code>(1110)</code>加一<code>(1111)</code>。所以<code>-1</code>在二进制中存储为<code>(1111)</code>。<code>-6</code>在二进制中储存为<code>(1010)</code>，6在二进制中储存为<code>(0110)</code>，他们只有 <strong>最后一个1及后面所有的0是相同的</strong> ，然后再取 <strong>与</strong> ，就得到了 <strong>最后一个1及后面所有的0</strong> 。这样就可以将数字拆分了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = k;i;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		sum+=T[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/bit/bit1.png" alt="bit1"></p>
<p>如上个例子所说，我们要查找前7个数的和，sum[7] = T[7] + T[6] + T[4]。而且我们可以发现<code>6 = 7 - lowbit(7)</code>，<code>4 = 6 - lowbit(6)</code>，而且<code>4 - lowbit(4)</code>刚好等于0，就可以作为循环结束，于是我们只需要一个循环依次来减去他的<code>lowbit</code>即可得到拆分后的序列，然后相加即可。妙哉妙哉！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        sum += T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果说对于某个区间的求和，利用前缀和的思想，对左节点和右节点依次求和，然后相减，over。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l<span class="number">-1</span>;i;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        sum1 += T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r;i;i = <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        sum2 += T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum2 - sum1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>对于某个数字要修改的话，我们需要找到其父亲节点一起修改。</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/bit/bit1.png" alt="bit1"></p>
<p>还是用这个图，如果我们要修改A[3]的值，那么T[3]，T[4]，T[8]都要修改。那么怎么从3得到4和8呢，万能的lowbit又登场辣。</p>
<p>仔细观察可以发现，<code>4 = 3 + lowbit(3)</code>， <code>8 = 4 + lowbit(4)</code>，一直到超出范围再停止，妙蛙，一个循环又搞定了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        T[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改，单点查询"><a href="#区间修改，单点查询" class="headerlink" title="区间修改，单点查询"></a>区间修改，单点查询</h3><p>区间修改没法了，如果一个一个修改这就太麻烦了，那就买个挂吧，对于区间修改特别是多次的区间修改，最容易想到的就是差分。那么ok，那我们就创建一个差分的树状数组呗，这不就搞定了吗。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos;i &lt;= n;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">update</span>(l, k);</span><br><span class="line"><span class="built_in">update</span>(r+<span class="number">1</span>, -k);</span><br></pre></td></tr></table></figure>
<p>然后再对差分数组求和就可以得到答案了，差分数组的特点嘛。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = pos; i; i-= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		sum += c[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改，区间查询"><a href="#区间修改，区间查询" class="headerlink" title="区间修改，区间查询"></a>区间修改，区间查询</h3><p>同样是利用差分，推个公式，利用两个树状数组维护即可，先挖坑了。</p>
<h3 id="建立树状数组"><a href="#建立树状数组" class="headerlink" title="建立树状数组"></a>建立树状数组</h3><p>说半天发现没有说怎么建立T数组。</p>
<p>建立树状数组可以将看作元素为0的单点修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        T[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">change</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over!</p>
<hr>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>线段树和树状数组一样，他储存的是原数组中某个区间的信息，但是他比树状数组更加全能，用树状数组能实现的基本上都能用线段树来实现，反之则不一定成立，但是树状数组的常数比线段树小。</p>
<p><strong>只要是某个大区间的信息能够由两个更小区间的信息合并而来，那么就可以用线段树来进行处理。</strong></p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.8/image/sigment tree/pic1.png" alt="pic1"></p>
<h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><p>观察上图，这就是一颗很普通的线段树，其中1号节点储存的是原数组中<code>1-4</code>的信息，2号存储<code>1-2</code>的信息，4号储存<code>1-1</code>的信息。如果我们想知道<code>1-2</code>的信息，那么我们可以由<code>1-1</code> ， <code>2-2</code>的信息合并而来，同理，如果我们想知道<code>1-3</code>的信息，那么我们可以用<code>1-2</code> ， <code>3-3</code>的信息合并起来。而且我们在预处理的时候就能够将<code>1-2</code>的信息给处理出来，这样就可以直接使用处理好的信息。</p>
<p>如果我们想修改某个区间的信息，例如<code>2-2</code>的信息，那么我们只需要修改5，2，1三个节点的数据即可。</p>
<p>查询的时间复杂度为<code>O(log n)</code> ，修改的复杂度为<code>O(log n)</code>。</p>
<h2 id="详细知识-1"><a href="#详细知识-1" class="headerlink" title="详细知识"></a>详细知识</h2><p><a target="_blank" rel="noopener" href="http://106.13.49.176/contest/25/problem/A">代码例题</a></p>
<p>对于此题，每个节点需要储存的信息为，节点左边界，右边界，区间和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, r;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">&#125;tree[maxn * <span class="number">4</span>]; <span class="comment">// 线段树一般开4倍空间</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[maxn];<span class="comment">//原数组</span></span><br></pre></td></tr></table></figure>
<h3 id="开点建树"><a href="#开点建树" class="headerlink" title="开点建树"></a>开点建树</h3><p>利用数组来模拟树，以<code>p*2</code>为左节点，<code>p*2+1</code>为右节点，每个节点处理一半的信息。注意当当前区间左节点与右节点相同时，代表已经到达了叶子节点，此时的信息可以从数组中直接得到。由于递归，当左右两颗树都建好了，那么左右两颗树的信息也都处理好了，此时就能够由两颗树直接处理。时间复杂度为<code>O(nlogn)</code> 。详细看代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p: 当前节点编号</span></span><br><span class="line"><span class="comment">l: 当前节点左边界</span></span><br><span class="line"><span class="comment">r: 当前节点右边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tree[p].l = l;</span><br><span class="line">	tree[p].r = r;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;<span class="comment">//到了最下方的节点，此时节点直接对应数组</span></span><br><span class="line">		tree[p].sum = a[l]; <span class="comment">// l-l的和就是a[l]，因为只有一个节点，其他情况自由发挥</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">//将当前区间分割成两个小区间</span></span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>, l, mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	tree[p].sum = tree[p*<span class="number">2</span>].sum + tree[p*<span class="number">2</span>+<span class="number">1</span>].sum; <span class="comment">// 大区间的和为两个小区间的和之和c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>题目中的操作2，如果我们想知道 <code>[l,r]</code> 的和，那么我们直接去线段树中去寻找即可，注意区间的划分，详细看代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p: 当前节点</span></span><br><span class="line"><span class="comment">l: 目标区间左端点</span></span><br><span class="line"><span class="comment">r: 目标区间右端点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[p].l &gt;= l &amp;&amp; tree[p].r &lt;= r) <span class="keyword">return</span> tree[p].sum; <span class="comment">// 当前节点所存储的区间在目标区间之内，那么我们直接用当前节点的信息即可</span></span><br><span class="line">	<span class="type">int</span> mid = (tree[p].l + tree[p].r) / <span class="number">2</span>; <span class="comment">// 注意是将当前区间分割成两半</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid &gt;= l)  sum += <span class="built_in">query</span>(p*<span class="number">2</span>, l, r); <span class="comment">// 如果有部分目标区间在当前区间所划分的左区间之内，那么去左区间瞅瞅</span></span><br><span class="line">	<span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= r) sum += <span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>, l, r); <span class="comment">// 如果有部分目标区间在当前区间所划分的右区间之内，那么去右区间瞅瞅</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，操作2已经完成，即线段树的查询已经结束。接下来是更新的内容了。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>先来常规更新</p>
<h4 id="常规更新"><a href="#常规更新" class="headerlink" title="常规更新"></a>常规更新</h4><p>与查询类似，如果要更新某个区间的值，那么我们只需要不断的去寻找这个区间，把最下面的节点更改掉，然后更新一下节点的和即可。注意此时的复杂度为<code>O(n log n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p: 当前节点</span></span><br><span class="line"><span class="comment">l: 目标区间左端点</span></span><br><span class="line"><span class="comment">r: 目标区间右端点</span></span><br><span class="line"><span class="comment">k: 增加的数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[p].l == tree[p].r)&#123; <span class="comment">// 到达叶子节点</span></span><br><span class="line">		tree[p].sum += k; <span class="comment">// 区间增加分解到点增加</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (tree[p].l + tree[p].r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid &gt;= l) <span class="built_in">update</span>(p*<span class="number">2</span>, l, r, k); <span class="comment">// 如果有部分目标区间在当前区间所划分的左区间之内，那么去左区间改改</span></span><br><span class="line">	<span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= r) <span class="built_in">update</span>(p*<span class="number">2</span>+<span class="number">1</span>, l, r, k); <span class="comment">// 如果有部分目标区间在当前区间所划分的右区间之内，那么去右区间改改。</span></span><br><span class="line">	tree[p].sum = tree[p*<span class="number">2</span>].sum + tree[p*<span class="number">2</span>+<span class="number">1</span>].sum; <span class="comment">// 更新当前区间新的和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这样看起来虽然很高级，但是也有点傻。线段树他是储存的区间信息，那么我们可不可以先把区间处理了，小区间先放一放，等后面要用小区间的信息了再去处理，这样是不是会快一些。此时，我们引入<strong>懒标记</strong> 。</p>
<h4 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h4><p>懒标记是对区间是否应该修改进行标记。是否应该修改，应该怎么修改，应该修改多少等等等等，这些都能用懒标记来进行懒处理。</p>
<p>懒标记主要体现在一个懒字，正如上文所说，我们可以先不处理小区间的信息，先处理大区间的信息，把小区间需要处理标记一下，等下次要用这个小区间了，再来处理这个小区间。说起来有点抽象，下面用代码来解释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> mark[maxn * <span class="number">4</span>]; <span class="comment">// 懒标记是对线段树节点进行懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p] != <span class="number">0</span>)&#123; <span class="comment">// 如果存在懒标记</span></span><br><span class="line">        <span class="type">int</span> l = tree[p].l, r = tree[p].r;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        mark[p*<span class="number">2</span>] += mark[p]; <span class="comment">// 懒标记往下传</span></span><br><span class="line">        mark[p*<span class="number">2</span>+<span class="number">1</span>] += mark[p];</span><br><span class="line">        tree[p*<span class="number">2</span>].sum += (mid - l + <span class="number">1</span>) * mark[p]; <span class="comment">// 区间增加相同的数，即区间和增加 数字*数量</span></span><br><span class="line">        tree[p*<span class="number">2</span>+<span class="number">1</span>].sum += (r - (mid+<span class="number">1</span>) + <span class="number">1</span>) * mark[p];</span><br><span class="line">        mark[p] = <span class="number">0</span>; <span class="comment">// 清楚当前节点的懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l &gt;= l &amp;&amp; tree[p].r &lt;= r)&#123;</span><br><span class="line">        tree[p].sum += (tree[p].r - tree[p].l + <span class="number">1</span>) * k;</span><br><span class="line">        mark[p] += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);<span class="comment">// 把当前节点的懒标记传下去</span></span><br><span class="line">    <span class="type">int</span> mid = (tree[p].l + tree[p].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= l) <span class="built_in">update</span>(p*<span class="number">2</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= r) <span class="built_in">update</span>(p*<span class="number">2</span>+<span class="number">1</span>, l, r, k);</span><br><span class="line">    tree[p].sum = tree[p*<span class="number">2</span>].sum + tree[p*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[p].l &gt;= l &amp;&amp; tree[p].r &lt;= r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="comment">// 注意懒标记</span></span><br><span class="line">	<span class="type">int</span> mid = (tree[p].l + tree[p].r) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid &gt;= l)  sum += <span class="built_in">query</span>(p*<span class="number">2</span>, l, r);</span><br><span class="line">	<span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= r) sum += <span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意建树，修改，查询时，都是从最大的节点，即1号节点开始走。</p>
<h3 id="例题完整代码"><a href="#例题完整代码" class="headerlink" title="例题完整代码"></a>例题完整代码</h3><p>下面给出题目完整代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, r;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">&#125;tree[maxn * <span class="number">4</span>]; <span class="comment">// 线段树一般开4倍空间</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[maxn], mark[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tree[p].l = l;</span><br><span class="line">	tree[p].r = r;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;<span class="comment">//到了最下方的节点，此时节点直接对应数组</span></span><br><span class="line">		tree[p].sum = a[l]; <span class="comment">// l-l的和就是a[l]，因为只有一个节点，其他情况自由发挥</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">//将当前区间分割成两个小区间</span></span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>, l, mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	tree[p].sum = tree[p*<span class="number">2</span>].sum + tree[p*<span class="number">2</span>+<span class="number">1</span>].sum; <span class="comment">// 大区间的和为两个小区间的和之和c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p] != <span class="number">0</span>)&#123; <span class="comment">// 如果存在懒标记</span></span><br><span class="line">        <span class="type">int</span> l = tree[p].l, r = tree[p].r;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        mark[p*<span class="number">2</span>] += mark[p]; <span class="comment">// 懒标记往下传</span></span><br><span class="line">        mark[p*<span class="number">2</span>+<span class="number">1</span>] += mark[p];</span><br><span class="line">        tree[p*<span class="number">2</span>].sum += (mid - l + <span class="number">1</span>) * mark[p]; <span class="comment">// 区间增加相同的数，即区间和增加 数字*数量</span></span><br><span class="line">        tree[p*<span class="number">2</span>+<span class="number">1</span>].sum += (r - (mid+<span class="number">1</span>) + <span class="number">1</span>) * mark[p];</span><br><span class="line">        mark[p] = <span class="number">0</span>; <span class="comment">// 清楚当前节点的懒标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l &gt;= l &amp;&amp; tree[p].r &lt;= r)&#123;</span><br><span class="line">        tree[p].sum += (tree[p].r - tree[p].l + <span class="number">1</span>) * k;</span><br><span class="line">        mark[p] += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);<span class="comment">// 把当前节点的懒标记传下去</span></span><br><span class="line">    <span class="type">int</span> mid = (tree[p].l + tree[p].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= l) <span class="built_in">update</span>(p*<span class="number">2</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= r) <span class="built_in">update</span>(p*<span class="number">2</span>+<span class="number">1</span>, l, r, k);</span><br><span class="line">    tree[p].sum = tree[p*<span class="number">2</span>].sum + tree[p*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[p].l &gt;= l &amp;&amp; tree[p].r &lt;= r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="comment">// 注意懒标记</span></span><br><span class="line">	<span class="type">int</span> mid = (tree[p].l + tree[p].r) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid &gt;= l)  sum += <span class="built_in">query</span>(p*<span class="number">2</span>, l, r);</span><br><span class="line">	<span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= r) sum += <span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>, l, r)&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l, r, k;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, r, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，线段树解释完毕。</p>
<hr>
<h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><p>先拜谢<a target="_blank" rel="noopener" href="https://space.bilibili.com/120174936?spm_id_from=333.788.b_765f7570696e666f.1">AgOH大佬</a>带我主席树入门，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1C4411u7rK?p=2&amp;spm_id_from=pageDriver">巨巨的教程</a>比我详细多了，我这里没看懂的可以去他哪里看。此处仅讲不修改权值的主席树。</p>
<h2 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h2><p>主席树最初是用来解决区间第k大问题的，<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】主席树</a>，但是用一般的方法，先将区间弄出来，排序，然后再来找肯定会超时，据说是黄嘉泰黄佬最早使用了主席树这个数据结构解决这个问题，为啥叫主席，黄嘉泰（HJT），你品，你细品，啥也不敢想啥也不敢说。</p>
<p>主席树也叫可优化式权值线段树，函数式线段树，函数式，也就是说这个线段树是可以进行拼合与拆解的，将线段树拆分成了无数个小的线段树。</p>
<p>但是如果每个线段树都要一一储存下来，这肯定会爆内存，于是呢，可以简化一下，仅仅储存以当前节点为根节点的左儿子，右儿子，数量。然后儿子又有儿子，无限套娃下去，树就出来辣。之后再来无限套娃，每个状态的树都能出来辣。又因为主席树是可以拆分的，类似于前缀和，就可以得到处于某个区间的状态的树。然后再来找第k大就很简单了。</p>
<h2 id="详细知识-2"><a href="#详细知识-2" class="headerlink" title="详细知识"></a>详细知识</h2><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>首先第一步需要对数据进行离散化，所谓离散化其实就是将大化小，仅保留重要的信息，对于处理主席树的问题，最重要的是数字的大小关系，其数值本身其实并不重要，我们只需要知道数字的大小关系，然后在关系表中去查，即可找到其真实数字。</p>
<p>比如对于模板题中的数据，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>25957</th>
<th>6405</th>
<th>15770</th>
<th>26287</th>
<th>26465</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>我们可以仅保留大小关系，离散化为</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>3</th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>这样我们的节点数量就大大减少。然后从后面得到了节点编号后，也可以通过关系再返回原数据。</p>
<p>贴代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//此处为由普通数据得到离散化后的数据，即25957 -&gt; 3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分查找数据，然后可以得到数据再其中的位置</span></span><br><span class="line">    <span class="comment">//二者择一即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">eng</span>(), num) - v.begin + <span class="number">1</span>; <span class="comment">//巨巨常用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), num) - <span class="number">1</span> - v.<span class="built_in">begin</span>() + <span class="number">1</span>;<span class="comment">//我目前使用的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="comment">//此处为离散化过程</span></span><br><span class="line">    <span class="comment">//将数据放入vector容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        v.<span class="built_in">push_back</span>(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将vector容器中所有数据排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//去重，unique函数将所有重复数据放到末尾，然后返回非重复数据的最后一个，</span></span><br><span class="line">    <span class="comment">//之后利用earse将末尾的重复数据删除，即得到全部数据的序列，序列包含了数据的大小信息与数据</span></span><br><span class="line">    v.<span class="built_in">earse</span>(<span class="built_in">unique</span>(v.<span class="built_in">bigin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//离散化完成</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处详细解释<code>v.earse(unique(v.begin(), v.end()), v.end)</code> 与 <code>upper_bound()</code></p>
<h4 id="earse"><a href="#earse" class="headerlink" title="earse"></a>earse</h4><p><code>unique</code>函数会将范围中的所有重复数据放到序列的末尾，并且返回非重复数据末尾的迭代器。</p>
<p>比如对于<code>1 2 2 4 4 5</code> ，经过此函数之后会变成<code>1 2 4 5 2 4</code>，然后返回第二个<code>2</code> 的位置，使用<code>earse</code>擦除掉从此处到整个数据结尾的数据，最后就会得到<code>1 2 4 5</code>，就达到完全去重的目的辣。</p>
<h4 id="upper-bound与lower-bound"><a href="#upper-bound与lower-bound" class="headerlink" title="upper_bound与lower_bound"></a>upper_bound与lower_bound</h4><p>现在大多数教程包括巨巨的教程其实都用的<code>lower_bound</code> ，但是我再做题的过程中发现有奇怪的地方，因此我更建议用 <code>upper_bound</code> ，如果有容易出现错误的地方请各路大佬指正。</p>
<p><code>lower_bound</code> 是在区间中查找大于等于某个数的位置，返回一个迭代器。这就涉及到一个问题，如果再后续查点的时候，点并不在初始化的数据之中就会非常麻烦。</p>
<p>比如再 <code>1 2 4 5</code> 中用<code>lower_bound()</code> 查找<code>2</code>与<code>3</code> ，理论上应该都是查出来<code>2</code> ，但是在实际情况中，查找出来却是<code>2</code> 与 <code>3</code>，因为一个刚好等于不需要向右偏移，而一个是大于需要偏移，就有点小麻烦，要再处理。</p>
<p><code>upper_bound</code> 是在区间中查找大于某个数的位置，返回位置的迭代器。</p>
<p>如果使用 <code>upper_bound()</code> ，都让他向右偏移一个位置，然后再减回来，这样就是正确位置，就不需要在处理。</p>
<p>博主在 <a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=4417">Super Mario</a> 发现此方法。</p>
<p>此处仁者见仁智者见智。</p>
<h3 id="开点建树-1"><a href="#开点建树-1" class="headerlink" title="开点建树"></a>开点建树</h3><p>先上代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l;<span class="comment">//左儿子</span></span><br><span class="line">    <span class="type">int</span> r;<span class="comment">//右儿子</span></span><br><span class="line">    <span class="type">int</span> sum;<span class="comment">//当前节点所含有的数量</span></span><br><span class="line">&#125;hjt[maxn * <span class="number">20</span>];<span class="comment">//主席树数组</span></span><br><span class="line"><span class="type">int</span> cnt, root[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre, <span class="type">int</span> &amp;now, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    hjt[++cnt] = hjt[pre];<span class="comment">//将原树复制一份</span></span><br><span class="line">    now = cnt;<span class="comment">//更新当前节点编号，顺便让上一个节点只想当前节点（引用）</span></span><br><span class="line">    hjt[now].sum++;<span class="comment">//节点sum++</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;<span class="comment">//终止条件</span></span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(l, mid, hjt[pre].l, hjt[now].l, p);<span class="comment">//往左收敛，与原树的左儿子为模板，创建当前节点的左儿子</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(mid + <span class="number">1</span>, r, hjt[pre].r, hjt[now].r, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>, n, root[i<span class="number">-1</span>], root[i], <span class="built_in">getid</span>(num[i]));<span class="comment">//传入的是离散化之后的数据并不是原数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会传入<code>pre</code>，也就是前模板，然后将前模板复制一次作为当前树节点，当前节点的<code>sum++</code> ，这样的话，每个同一位置的相同不同节点，除了sum值每次加一，改变了的儿子就会新建一个节点去连接，剩下的那个儿子是不改变的，使用的是原来已经创建好的节点，就达到了节省空间的目的。</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/hjt/hjt1.png" alt="image-1"></p>
<p>来举个栗子，对于上图<code>3 1 2 4 5</code> 序列，树的编号看作①-⑨，<strong>其实是没有编号的，没有任何意义，仅仅是为了方便演示</strong>。</p>
<p>第一步<code>3</code>进树，<strong>此时位于①号节点</strong>，原模板<code>pre = root[0] = 0</code>，<code>hjt[++cnt] = hjt[pre]</code> 之后<code>cnt = 1</code>，<code>hjt[1]</code> 以<code>hjt[0]</code>复制了一份，<code>l = 0, r = 0, sum = 0</code> 。<code>now = cnt</code>，由于引用，<code>root[1] = now = 1</code>。<code>hjt[now].sum++ = 1</code> 。</p>
<p>二分之后，<strong>进入②号节点</strong>，原模板<code>pre = 上一个节点的原模板的左节点 = hjt[0].l = 0</code>，<code>hjt[++cnt] = hjt[pre]</code> 之后<code>cnt = 2</code>， <code>hjt[2]</code> 以 <code>hjt[0]</code> 复制一份，<code>l = 0， r = 0, sum = 0</code>。<code>now = cnt</code>，由于引用，上一个节点的左儿子发生改变，<code>hjt[1].l = now = 2</code>。<code>hjt[1].l = 2, hjt[1].r = 0</code>，<code>hjt[2].l = 0, hjt[r] = 0</code>，1号节点与2号节点连接成功。<code>hjt[now].sum++ = 1</code>。</p>
<p>二分之后，<strong>进入⑤号节点</strong>，原模板<code>pre = 上一个节点的原模版的右节点 = hjt[0].r = 0</code>，<code>hjt[++cnt] = hjt[pre]</code>之后<code>cnt = 3</code>，<code>hjt[3]</code>以<code>hjt[0]</code>复制一份，<code>l = 0, r = 0, sum = 0</code>。<code>now = cnt</code>，由于引用，上一个节点的右儿子发生改变，<code>hjt[2].r = now = 3</code>。<code>hjt[1].l = 2, hjt[1].r = 0</code>， <code>hjt[2].l = 0, hjt[2].r = 3</code>， <code>hjt[3].l = 0, hjt[3].r = 0</code>，1号节点与2号节点与三号节点连接成功，即①，②，⑤连接成功，<code>3</code>进入的状态的树建立成功。<code>hjt[now].sum++</code> = 1。</p>
<p>第二步<code>1</code>进树，<strong>此时位于①号节点</strong>，原模版<code>pre = root[1] = 1</code>，<code>hjt[++cnt] = hjt[pre]</code>之后<code>cnt = 4</code>，<code>hjt[4]</code> 以 <code>hjt[1]</code> 复制一份，<code>l = 2, r= 0, sum = 1</code>。<code>now = cnt</code>， 由于引用，<code>root[2] = now = 4</code>。<code>hjt[now].sum++ = 2</code>。</p>
<p>二分之后，<strong>进入②号节点</strong>，原模板<code>pre = 上一个节点的原模板的左节点 = hjt[1].l = 2</code>，<code>hjt[++cnt] = hjt[pre]</code>之后<code>cnt = 5</code>，<code>hjt[5]</code> 以<code>hjt[2]</code>复制了一份<code>l = 0, r= 3, sum = 1</code>。<code>now = cnt</code> 由与引用，上一个节点的左儿子发生变化，<code>hjt[4].l = now = 5</code>，<code>hjt[4].l = 5, hjt[4].r = 0</code>，<code>hjt[5].l = 0，hjt[5].r = 3</code>。<code>hjt[now].sum++ = 2</code>，4号与5号连接成功，并且5号与3号也是连接起来的，这就相当于在原来的基础上多创建了一个分支！！！这就是线段树的精髓所在。</p>
<p>二分之后，<strong>进入④号节点</strong>，原模版<code>pre = 上一个节点的原模版的左节点 = hjt[2].l = 0</code>，<code>hjt[++cnt] = hjt[pre]</code>之后<code>cnt = 6</code>，<code>hjt[6]</code>以<code>hjt[0]</code>复制一份，<code>l = 0, r = 0, sum = 0</code>。<code>now = cnt</code>，由于引用，上一个节点的左儿子发生变化，<code>hjt[5].l = now = 6</code>。<code>hjt[4].l = 5,hjt[4].r = 0</code>, <code>hjt[5].l = 5,hjt[5].r = 3</code>,<code>hjt[6].l = 0,hjt[6].r = 0</code>。<code>hjt[now].sum++ = 1</code>。</p>
<p>后面就不再演示。与上同理。</p>
<p>通过演示可以发现，<code>root[1] = 1</code>, <code>root[2] = 4</code>，这其实是每一颗新树的根节点编号。<code>hjt[5].r = 3</code>，可以发现他使用的是原来已经创建好的节点，仅仅去改变需要改变的<code>l</code>分支，就十分的节省空间。也就达到了下面这张图的目的。</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/hjt/hjt2.png" alt="image-2"></p>
<p>而且我们可以发现一个重要的结论，线段树是可以加减拆分的，例如<code>hjt[root[2]].sum - hjt[root1].sum = 1</code>，表示的是单独<code>1</code>进树的节点数量状态。</p>
<p>例如此为<code>3 1 2 4 5</code>全部入树的状态</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/hjt/hjt3.png" alt="image-3"></p>
<p>此为<code>3 1</code>入树状态</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/hjt/hjt4.png" alt="image-4"></p>
<p>两者相减之后即为<code>2 4 5</code>入树的状态</p>
<p><img src="https://npm.elemecdn.com/crotes-blog@1.0.5/image/hjt/hjt5.png" alt="image-5"></p>
<p>所以主席树真的是非常神奇啊！大佬牛逼！！！</p>
<h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>上代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;l&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp = hjt[hjt[R].l].sum - hjt[hjt[L].l].sum;<span class="comment">//左子树上有多少个数字,外面已经减过1了，这里就不用减1了</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= temp)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, mid, hjt[L].l, hjt[R].l, k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(mid + <span class="number">1</span>, r, hjt[L].r, hjt[R].r, k - temp);<span class="comment">//全部的第k大也就是右边的第k-左大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        cout&lt;&lt;v[<span class="built_in">query</span>(<span class="number">1</span>, n, root[l<span class="number">-1</span>], root[r], k) - <span class="number">1</span>]&lt;&lt;endl;<span class="comment">//*</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<code>[L,R]</code>应该的从 <code>R</code> 到 <code>L-1</code>，所以应该的<code>root[R]</code>这棵树减去<code>root[L-1]</code>这棵树才是<code>[L,R]</code>这颗树。</p>
<p>然后就是query里面的第二个else，全部范围的第k大应该是右边的第k-左大，比如一共有6个数字，左边3个右边3个，一共的第5大应该的右边的第5 - 3大。</p>
<p>最后，由于最开始是存的离散化之后的数据，需要反引用，又因为编号大小是从1开始的，而数据是从0开始的需要减1。</p>
<p>至此，主席树解释完毕。</p>
<h2 id="模板题代码"><a href="#模板题代码" class="headerlink" title="模板题代码"></a>模板题代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, sum;</span><br><span class="line">&#125;hjt[maxn*<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> cnt, root[maxn];</span><br><span class="line"><span class="type">int</span> num[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre, <span class="type">int</span> &amp;now, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    hjt[++cnt] = hjt[pre];<span class="comment">//将原树复制一份</span></span><br><span class="line">    now = cnt;</span><br><span class="line">    hjt[now].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(l, mid, hjt[pre].l, hjt[now].l, p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(mid + <span class="number">1</span>, r, hjt[pre].r, hjt[now].r, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp = hjt[hjt[R].l].sum - hjt[hjt[L].l].sum;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= temp)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, mid, hjt[L].l, hjt[R].l, k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(mid + <span class="number">1</span>, r, hjt[L].r, hjt[R].r, k - temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        v.<span class="built_in">push_back</span>(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="number">1</span>, n, root[i<span class="number">-1</span>], root[i], <span class="built_in">getid</span>(num[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        cout&lt;&lt;v[<span class="built_in">query</span>(<span class="number">1</span>, n, root[l<span class="number">-1</span>], root[r], k) - <span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h2><p>字典树故名思意就是和字典一样的，一个字母一个字母来查，分流，然后形成一个在<code>O(L)</code>时间内查找到字符串的树形结构，非常非常快，与哈希相比在处理长字符串更有优势，而且随时可以新增。但是空间复杂度巨大无比，典型的空间换时间。<code>O(N*L)</code>，最大字符串数量乘以最大字符串长度。</p>
<h2 id="详细知识-3"><a href="#详细知识-3" class="headerlink" title="详细知识"></a>详细知识</h2><p>其实字典树就是每个节点有26个儿子节点的树，和以前的差不多，直接上代码了。哦对了，根节点的编号是0，也就是说根节点连的每个字符串的第一个字母。然后就没啥注意点了。</p>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">26</span>];</span><br><span class="line">&#125;trie[manx * maxl];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[now].son[ch] == <span class="number">0</span>)&#123;</span><br><span class="line">            trie[now].son[ch] == ++cnt;<span class="comment">//动态开点</span></span><br><span class="line">        &#125;</span><br><span class="line">        now = trie[now].son[ch];<span class="comment">//层层深入</span></span><br><span class="line">    &#125;</span><br><span class="line">    root[now] = id;<span class="comment">//最后一个位置标记当前字符串的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于字符串一个字母代表一层，每过一个字母就要深入一层，如果下一个字母没有就开一个空间给他，走到最后了，该字符串的分支就到了，标记一下就好了。</p>
<h3 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now = trie[now].son[ch];<span class="comment">//层层深入</span></span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span>)&#123;<span class="comment">//没有说明以前没有插入这个分支，就不存在咯</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root[now];<span class="comment">//走到最后一层了，把标记的编号输出即可，就是该字符串的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">26</span>];</span><br><span class="line">&#125;trie[maxn];</span><br><span class="line"><span class="type">int</span> cnt, root[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[now].son[ch] == <span class="number">0</span>)&#123;</span><br><span class="line">            trie[now].son[ch] = ++cnt;<span class="comment">//动态开点</span></span><br><span class="line">        &#125;</span><br><span class="line">        now = trie[now].son[ch];</span><br><span class="line">    &#125;</span><br><span class="line">    root[now] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">        ch = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now = trie[now].son[ch];</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        <span class="built_in">insert</span>(str,i);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">search</span>(str)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over！</p>
<hr>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="基础知识-4"><a href="#基础知识-4" class="headerlink" title="基础知识"></a>基础知识</h2><p>最小生成树是图的给你N个节点，M条边，让你在M条边中找N-1条边使N个节点联通，并且权值和最小，当前情况形成的树称为最小生成树。生成最小生成树常用两种方法， 分别是<code>Prim</code>与<code>Kruskal</code>。</p>
<blockquote>
<p><code>Prim</code>在稠密图中比<code>Kruskal</code>优，在稀疏图中比<code>Kruskal</code>劣。</p>
</blockquote>
<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p>Prim是对每个点周围找最短的边，然后将这个边怼进去，对这个集合找所连的边的最短边怼进去，重复下去就找到了最小生成树了。</p>
<p><code>dis[maxn]</code>储存当前集合到其他点的距离，初始化为inf，相当于把当前集合所连边怼进集合，注意取最小值，因为可能有重边。</p>
<p><code>vis[maxn]</code>用来标记每个点，已经找到的点就标记起来，不用再去找了</p>
<p><code>tot</code>表示边的数量，数量等于n-1时结束查找</p>
<p><code>ans</code>表示最后答案，也就是最小树的权值和</p>
<p>用链式前向星储存答案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dis[maxn], vis[maxn], tot, ans;<span class="comment">//边集合，边数量，答案</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;<span class="comment">//从节点1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) dis[i] = inf;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now];i;i = edge[i].next)&#123;<span class="comment">//将当前节点的所连的所有边放进集合</span></span><br><span class="line">        dis[edge[i].to] = <span class="built_in">min</span>(dis[edge[i].to], edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot &lt;= n<span class="number">-1</span>)&#123;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> min_now = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;<span class="comment">//寻找与当前集合所连边的最小边，注意这里是1到n，当找不到最小值时，原图未连通</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; dis[i] &lt; min_now)&#123;</span><br><span class="line">                min_now = dis[i];</span><br><span class="line">                now = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += min_now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[now];i;i = edge[i].next)&#123;<span class="comment">//将边放进去</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].to])&#123;<span class="comment">//边所连的点已经标记好了就不用放了</span></span><br><span class="line">                dis[edge[i].to] = <span class="built_in">min</span>(dis[edge[i].to], edge[i].w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p><code>Kruskal</code>与<code>Prim</code>相似，不过<code>Kruskal</code>是将所有边中最小的边一个一个连，然后利用并查集来判断两点是否连接，未连接就用这个较小边来连接，否则就寻找下一个边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> Edge p, <span class="keyword">struct</span> Edge q)</span></span>&#123;<span class="comment">//将所有边按权值从小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> p.w &lt; q.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans, tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(edge, edge + m,cmp);<span class="comment">//这里不需要太在意是否有方向，只需要关注两个节点，因此单向边即可，只有m条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> rootp = <span class="built_in">find</span>(edge[i].from);</span><br><span class="line">		<span class="type">int</span> tootq = <span class="built_in">find</span>(edge[i].to);</span><br><span class="line">		<span class="keyword">if</span>(rootp == rootq) <span class="keyword">continue</span>;<span class="comment">//如果两个点已经连接，跳过当前边</span></span><br><span class="line">		id[rootp] = rootq;<span class="comment">//连接起来</span></span><br><span class="line">		ans += edge[i].w;</span><br><span class="line">		<span class="keyword">if</span>(++tot == n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//找到n-1条边结束，如果到最后都没有找到n-1条边，说明原图未连通</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></p>
<h3 id="Prim-1"><a href="#Prim-1" class="headerlink" title="Prim"></a>Prim</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x7ffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星部分</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edge[maxm&lt;&lt;<span class="number">1</span>];<span class="comment">//需要遍历一个点的所有边，因此需要双向边</span></span><br><span class="line"><span class="type">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Prim部分</span></span><br><span class="line"><span class="type">int</span> tot, ans, dis[maxn],vis[maxn];<span class="comment">//边数，权值和，集合，标记数组</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> jd;<span class="comment">//判断是否未连通</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;<span class="comment">//从节点1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;<span class="comment">//最开始集合初始化为正无穷，1不用初始化，因为1与1连通  </span></span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now];i;i = edge[i].next)&#123;<span class="comment">//将与1连通的所有边放进来，min是为了防止有重边</span></span><br><span class="line">        dis[edge[i].to] = <span class="built_in">min</span>(dis[edge[i].to], edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot &lt;= n<span class="number">-1</span>)&#123;</span><br><span class="line">        jd = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minn = inf;</span><br><span class="line">        vis[now] = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;<span class="comment">//找到集合里面最小边，注意是1-n</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; minn &gt; dis[i])&#123;</span><br><span class="line">                minn = dis[i];</span><br><span class="line">                now = i;</span><br><span class="line">                jd = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!jd) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果没有找到最小边，说明未连通</span></span><br><span class="line">        ans += minn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[now];i;i = edge[i].next)&#123;<span class="comment">//将新点的所有边放进集合</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].to])</span><br><span class="line">            dis[edge[i].to] = <span class="built_in">min</span>(dis[edge[i].to], edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);<span class="comment">//双向边</span></span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(jd) cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal-1"><a href="#Kruskal-1" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集部分</span></span><br><span class="line"><span class="type">int</span> id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == id[p]) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> id[p] = <span class="built_in">find</span>(id[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星部分</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from, to, w;   </span><br><span class="line">&#125;edge[maxm];<span class="comment">//这里是单向边，不用开两倍</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> edge p, <span class="keyword">struct</span> edge q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.w &lt; q.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kruskal部分</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans, tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">kruskal</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m, cmp);<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> rootp = <span class="built_in">find</span>(edge[i].from);</span><br><span class="line">        <span class="type">int</span> rootq = <span class="built_in">find</span>(edge[i].to);</span><br><span class="line">        <span class="keyword">if</span>(rootq == rootp) <span class="keyword">continue</span>;<span class="comment">//当前边的两点已经连通，跳过</span></span><br><span class="line">        ans += edge[i].w;<span class="comment">//连通</span></span><br><span class="line">        id[rootq] = rootp;</span><br><span class="line">        <span class="keyword">if</span>(++tot == n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//找到n-1条边即可退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;edge[i].from&gt;&gt;edge[i].to&gt;&gt;edge[i].w;<span class="comment">//kruskal只用考虑一边的两点，因此单向边足矣</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(tot == n<span class="number">-1</span>) cout&lt;&lt;ans;<span class="comment">//如果tot不等于n-1说明原图未连通</span></span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>over！</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>树</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://crotes.top/2021/04/15/%E6%A0%91/">http://crotes.top/2021/04/15/树/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Crotes</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-04-15</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-04-04</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ACM/">ACM</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/07/acm/"><img class="prev-cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ACM</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/11/%E5%9B%BE/"><img class="next-cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/31/CUIT%E6%96%B0%E7%94%9F%E6%B5%8B%E8%AF%95%E8%B5%9B/" title="CUIT新生测试赛"><img class="cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-31</div><div class="title">CUIT新生测试赛</div></div></a></div><div><a href="/2021/07/14/math/" title="math"><img class="cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-14</div><div class="title">math</div></div></a></div><div><a href="/2021/04/11/%E5%9B%BE/" title="图"><img class="cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-11</div><div class="title">图</div></div></a></div><div><a href="/2022/01/07/ACM%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9D%BF%E5%AD%90/" title="ACM头文件板子"><img class="cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-07</div><div class="title">ACM头文件板子</div></div></a></div><div><a href="/2022/01/06/CUIT%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/" title="CUIT第八届校赛题解"><img class="cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-06</div><div class="title">CUIT第八届校赛题解</div></div></a></div><div><a href="/2021/01/22/%E7%AE%97%E6%B3%95/" title="算法"><img class="cover" src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://npm.elemecdn.com/crotes-blog@1.0.2/blogimg/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Crotes</div><div class="author-info__description">现在大二了，还是个菜鸟<br/>/(ㄒoㄒ)/~~</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Crotes"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Crotes" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1910546917@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">本主题基于3.5.1</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E4%BC%98%E9%9B%85%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">树状数组-优雅的前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.</span> <span class="toc-text">详细知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lowbit"><span class="toc-number">1.2.1.</span> <span class="toc-text">lowbit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">区间查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">单点修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.4.</span> <span class="toc-text">区间修改，单点查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.5.</span> <span class="toc-text">区间修改，区间查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.6.</span> <span class="toc-text">建立树状数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1"><span class="toc-number">2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86-1"><span class="toc-number">2.2.</span> <span class="toc-text">详细知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E7%82%B9%E5%BB%BA%E6%A0%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">开点建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%9B%B4%E6%96%B0"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">常规更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%A0%87%E8%AE%B0"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">懒标记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">例题完整代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">主席树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2"><span class="toc-number">3.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86-2"><span class="toc-number">3.2.</span> <span class="toc-text">详细知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#earse"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">earse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#upper-bound%E4%B8%8Elower-bound"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">upper_bound与lower_bound</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E7%82%B9%E5%BB%BA%E6%A0%91-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">开点建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">模板题代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-3"><span class="toc-number">4.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86-3"><span class="toc-number">4.2.</span> <span class="toc-text">详细知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A0%91"><span class="toc-number">4.2.1.</span> <span class="toc-text">建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-2"><span class="toc-number">4.2.2.</span> <span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.3.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-4"><span class="toc-number">5.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prim"><span class="toc-number">5.2.</span> <span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal"><span class="toc-number">5.3.</span> <span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">5.4.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">Kruskal</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/07/ACM%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9D%BF%E5%AD%90/" title="ACM头文件板子"><img src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ACM头文件板子"/></a><div class="content"><a class="title" href="/2022/01/07/ACM%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9D%BF%E5%AD%90/" title="ACM头文件板子">ACM头文件板子</a><time datetime="2022-01-07T16:43:36.000Z" title="发表于 2022-01-07 16:43:36">2022-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/06/CUIT%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/" title="CUIT第八届校赛题解"><img src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CUIT第八届校赛题解"/></a><div class="content"><a class="title" href="/2022/01/06/CUIT%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/" title="CUIT第八届校赛题解">CUIT第八届校赛题解</a><time datetime="2022-01-06T23:18:50.000Z" title="发表于 2022-01-06 23:18:50">2022-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/CUIT%E6%96%B0%E7%94%9F%E6%B5%8B%E8%AF%95%E8%B5%9B/" title="CUIT新生测试赛"><img src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CUIT新生测试赛"/></a><div class="content"><a class="title" href="/2021/10/31/CUIT%E6%96%B0%E7%94%9F%E6%B5%8B%E8%AF%95%E8%B5%9B/" title="CUIT新生测试赛">CUIT新生测试赛</a><time datetime="2021-10-31T16:28:34.000Z" title="发表于 2021-10-31 16:28:34">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/22/%E6%A8%A1%E6%9D%BF/" title="模板"><img src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="模板"/></a><div class="content"><a class="title" href="/2021/10/22/%E6%A8%A1%E6%9D%BF/" title="模板">模板</a><time datetime="2021-10-22T20:37:29.000Z" title="发表于 2021-10-22 20:37:29">2021-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/11/dp/" title="dp"><img src="https://npm.elemecdn.com/crotes-blog@1.0.4/blogimg/index.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dp"/></a><div class="content"><a class="title" href="/2021/08/11/dp/" title="dp">dp</a><time datetime="2021-08-11T14:09:53.000Z" title="发表于 2021-08-11 14:09:53">2021-08-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Crotes</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello Hello,相见即是有缘,留下你的小脚印吧!!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><link rel="stylesheet" href="/css/my.css"><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>模板 | Crotes</title><meta name="keywords" content="ACM"><meta name="author" content="Crotes"><meta name="copyright" content="Crotes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="图 最短路 dijstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="模板">
<meta property="og:url" content="http://crotes.top/2021/10/22/%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="Crotes">
<meta property="og:description" content="图 最短路 dijstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg">
<meta property="article:published_time" content="2021-10-22T20:37:29.000Z">
<meta property="article:modified_time" content="2022-04-04T09:09:25.066Z">
<meta property="article:author" content="Crotes">
<meta property="article:tag" content="ACM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Crotes/jsd/image/facivon.png"><link rel="canonical" href="http://crotes.top/2021/10/22/%E6%A8%A1%E6%9D%BF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"ZFR9NSG98C","apiKey":"09f9eb2608090d91ffaca56eea403bf0","indexName":"crotes","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-04 09:09:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Crotes</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">模板</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-22T20:37:29.000Z" title="发表于 2021-10-22 20:37:29">2021-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-04T09:09:25.066Z" title="更新于 2022-04-04 09:09:25">2022-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ACM/">ACM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>图</h1>
<h2 id="最短路">最短路</h2>
<h3 id="dijstra">dijstra</h3>
<h2 id="code￼0"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//普通dijstra</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijstra1</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, min = dis[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; min)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[edge[i].to] == <span class="literal">false</span> &amp;&amp; dis[edge[i].to] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">                dis[edge[i].to] = dis[u] + edge[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆优化之后的dijstra</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, st&#125;);</span><br><span class="line">    PII t;</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</span><br><span class="line">        t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">int</span> now = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span>(vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[now] + edge[i].w)&#123;</span><br><span class="line">                dis[edge[i].to] = dis[now] + edge[i].w;</span><br><span class="line">                heap.push(&#123;dis[edge[i].to], edge[i].to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, st;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        <span class="keyword">if</span>(u == st) dis[v] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    dijstra(st, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i] == dis[<span class="number">0</span>]) <span class="built_in">cout</span>&lt;&lt;(<span class="number">2147483647</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;(dis[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="spfa">spfa</h3>
<h2 id="code￼1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2147483647</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">ll dis[maxn];</span><br><span class="line"><span class="keyword">int</span> num_cnt[maxn];</span><br><span class="line"><span class="comment">// SLF优化后的spfa</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spfa1</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> aim, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push_back(st);</span><br><span class="line">    vis[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    num_cnt[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        now = que.front();</span><br><span class="line">        que.pop_front();</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[now] + edge[i].w &lt; dis[edge[i].to])&#123;</span><br><span class="line">                dis[edge[i].to] = dis[now] + edge[i].w;</span><br><span class="line">                num_cnt[edge[i].to] = num_cnt[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num_cnt[edge[i].to] &gt; n) flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!que.empty() &amp;&amp; dis[edge[i].to] &gt;= dis[que.front()]) que.push_back(edge[i].to);</span><br><span class="line">                    <span class="keyword">else</span> que.push_front(edge[i].to);</span><br><span class="line">                    vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LLL优化后spfa</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spfa2</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> aim, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    que.push(st);</span><br><span class="line">    vis[st] = <span class="literal">true</span>;</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    num_cnt[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = que.front();</span><br><span class="line">        <span class="keyword">while</span>(dis[now] * num &gt; sum)&#123;</span><br><span class="line">            que.pop();</span><br><span class="line">            que.push(now);</span><br><span class="line">            now = que.front();</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">        num--;</span><br><span class="line">        sum -= dis[now];</span><br><span class="line">        vis[now] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[now] + edge[i].w)&#123;</span><br><span class="line">                dis[edge[i].to] = dis[now] + edge[i].w;</span><br><span class="line">                num_cnt[edge[i].to] = num_cnt[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num_cnt[edge[i].to] &gt; n) flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">                    que.push(edge[i].to);</span><br><span class="line">                    sum += dis[edge[i].to];</span><br><span class="line">                    num++;</span><br><span class="line">                    vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LLL+SLF优化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> aim, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push_back(st);</span><br><span class="line">    vis[st] = <span class="literal">true</span>;</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    num_cnt[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = que.front();</span><br><span class="line">        <span class="keyword">while</span>(num * dis[now] &gt; sum)&#123;</span><br><span class="line">            que.pop_front();</span><br><span class="line">            que.push_back(now);</span><br><span class="line">            now = que.front();</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop_front();</span><br><span class="line">        num--;</span><br><span class="line">        sum -= dis[now];</span><br><span class="line">        vis[now] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[now] + edge[i].w)&#123;</span><br><span class="line">                dis[edge[i].to] = dis[now] + edge[i].w;</span><br><span class="line">                num_cnt[edge[i].to] = num_cnt[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num_cnt[edge[i].to] &gt; n) flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!que.empty() &amp;&amp;(dis[edge[i].to] &lt;= dis[que.front()])) que.push_front(edge[i].to);</span><br><span class="line">                    <span class="keyword">else</span> que.push_back(edge[i].to);</span><br><span class="line">                    vis[edge[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    sum += dis[edge[i].to];</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(s, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i] == dis[<span class="number">0</span>]) <span class="built_in">cout</span>&lt;&lt;(inf);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;(dis[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="floyd">floyd</h3>
<h2 id="code￼2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line">ll dis[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][k] == dis[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                dis[i][j] = min(dis[i][j], (dis[i][k] + dis[k][j]));</span><br><span class="line">                dis[j][i] = dis[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            dis[u][v] = dis[v][u] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd(n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dis[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="johnson">johnson</h3>
<h2 id="code￼3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> aim, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dis[i] = maxl;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    heap.push(PII(<span class="number">0</span>, st));</span><br><span class="line">    PII t;</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</span><br><span class="line">        t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">int</span> now = t.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].to] &gt; dis[now] + edge[i].w)&#123;</span><br><span class="line">                dis[edge[i].to] = dis[now] + edge[i].w;</span><br><span class="line">                heap.push(PII(dis[edge[i].to], edge[i].to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line"><span class="keyword">int</span> num_cnt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> aim, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(h, INF, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push_back(st);</span><br><span class="line">    vis[st] = <span class="number">1</span>;</span><br><span class="line">    h[st] = <span class="number">0</span>;</span><br><span class="line">    num_cnt[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = que.front();</span><br><span class="line">        <span class="keyword">while</span>(num * h[now] &gt; sum)&#123;</span><br><span class="line">            que.pop_front();</span><br><span class="line">            que.push_back(now);</span><br><span class="line">            now = que.front();</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop_front();</span><br><span class="line">        num--;</span><br><span class="line">        sum -= h[now];</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h[edge[i].to] &gt; h[now] + edge[i].w)&#123;</span><br><span class="line">                h[edge[i].to] = h[now] + edge[i].w;</span><br><span class="line">                num_cnt[edge[i].to] = num_cnt[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num_cnt[edge[i].to] &gt; n) <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!que.empty() &amp;&amp; (h[edge[i].to] &lt;= h[que.front()])) que.push_front(edge[i].to);</span><br><span class="line">                    <span class="keyword">else</span> que.push_back(edge[i].to);</span><br><span class="line">                    vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">                    sum += h[edge[i].to];</span><br><span class="line">                    num++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(!n &amp;&amp; !m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            add(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            add(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now = <span class="number">1</span>;now &lt;= n;now++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">                edge[i].w += h[now] - h[edge[i].to];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dijstra(<span class="number">1</span>, n, n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="第K短路">第K短路</h2>
<p>AStar</p>
<h2 id="code￼4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100000</span> + <span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, next;</span><br><span class="line">&#125;edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> headz[maxn], cnt;</span><br><span class="line"><span class="keyword">int</span> headf[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f, g, from;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.f == f) <span class="keyword">return</span> g&gt;a.g;</span><br><span class="line">        <span class="keyword">return</span> f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = headz[u];</span><br><span class="line">    headz[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = headf[u];</span><br><span class="line">    headf[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(h, INF, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    PII t;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    h[st] = <span class="number">0</span>;</span><br><span class="line">    q.push(PII(h[st], st));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        t = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        now = t.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = headf[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h[edge[i].to] &gt; h[now] + edge[i].w)&#123;</span><br><span class="line">                h[edge[i].to] = h[now] + edge[i].w;</span><br><span class="line">                q.push(PII(h[edge[i].to], edge[i].to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">AStar</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st == ed) k++;</span><br><span class="line">    <span class="keyword">if</span>(h[st] == h[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    node tmp, to;</span><br><span class="line">    tmp.from = st;</span><br><span class="line">    tmp.g = <span class="number">0</span>;</span><br><span class="line">    tmp.f = tmp.g + h[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        tmp = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(tmp.from == ed) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> tmp.g;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = headz[tmp.from];i;i = edge[i].next)&#123;</span><br><span class="line">            to.from = edge[i].to;</span><br><span class="line">            to.g = tmp.g + edge[i].w;</span><br><span class="line">            to.f = to.g + h[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(headf, <span class="number">0</span>, <span class="keyword">sizeof</span>(headf));</span><br><span class="line">    <span class="built_in">memset</span>(headz, <span class="number">0</span>, <span class="keyword">sizeof</span>(headz));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            add1(u, v, w);</span><br><span class="line">            add2(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s, t, k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;k;</span><br><span class="line">        dijstra(t, s, n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;AStar(s, t, k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="prim">prim</h3>
<h2 id="code￼5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7ffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, next;</span><br><span class="line">&#125;edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, now, ans, dis[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> jd;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;  </span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">        dis[edge[i].to] = min(dis[edge[i].to], edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot &lt; n)&#123;</span><br><span class="line">        jd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = inf;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; minn &gt; dis[i])&#123;</span><br><span class="line">                minn = dis[i];</span><br><span class="line">                now = i;</span><br><span class="line">                jd = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!jd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans += minn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].to])</span><br><span class="line">            dis[edge[i].to] = min(dis[edge[i].to], edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    prim();</span><br><span class="line">    <span class="keyword">if</span>(jd) <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="KrusKal">KrusKal</h3>
<h2 id="code￼6"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == id[p]) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> id[p] = find(id[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w;   </span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(struct edge p, struct edge q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.w &lt; q.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans, tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    sort(edge, edge + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> rootp = find(edge[i].from);</span><br><span class="line">        <span class="keyword">int</span> rootq = find(edge[i].to);</span><br><span class="line">        <span class="keyword">if</span>(rootq == rootp) <span class="keyword">continue</span>;</span><br><span class="line">        ans += edge[i].w;</span><br><span class="line">        id[rootq] = rootp;</span><br><span class="line">        <span class="keyword">if</span>(++tot == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;edge[i].from&gt;&gt;edge[i].to&gt;&gt;edge[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal();</span><br><span class="line">    <span class="keyword">if</span>(tot == n<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="lca">lca</h2>
<h2 id="code￼7"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = y;</span><br><span class="line">    edge[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> depth[maxn], fa[maxn][<span class="number">21</span>], lg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fath)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = fath;</span><br><span class="line">    depth[now] = depth[fath] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; lg[depth[now]];i++)&#123;</span><br><span class="line">        fa[now][i] = fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to != fath) dfs(edge[i].to, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[x] &lt; depth[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">while</span>(depth[x] &gt; depth[y])&#123;</span><br><span class="line">        x = fa[x][lg[depth[x] - depth[y]] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = lg[depth[x] - <span class="number">1</span>];k &gt;= <span class="number">0</span>;k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][k] != fa[y][k])&#123;</span><br><span class="line">            x = fa[x][k];</span><br><span class="line">            y = fa[y][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n, &amp;m, &amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x, &amp;y);</span><br><span class="line">        add(x, y);</span><br><span class="line">        add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lca(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="二分图">二分图</h2>
<h3 id="匈牙利算法">匈牙利算法</h3>
<h2 id="code￼8"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1000050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1050</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> flag[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[maxn];<span class="comment">//原配</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[now];i;i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[edge[i].to])&#123;</span><br><span class="line">            vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!id[edge[i].to] || dfs(id[edge[i].to]))&#123;</span><br><span class="line">                id[edge[i].to] = now;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hungarian</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;e);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; e;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(!flag[u][v])</span><br><span class="line">        add(u, v),flag[u][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, hungarian(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>数论</h1>
<h2 id="gcd">gcd</h2>
<h2 id="code￼9"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="欧拉筛">欧拉筛</h2>
<h2 id="code￼10"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span>;</span><br><span class="line"><span class="keyword">int</span> isprime[N/<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;,num_prime = <span class="number">0</span>;<span class="comment">//质数数组，质数数量</span></span><br><span class="line"><span class="keyword">bool</span> isNotPrime[N] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N ; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!isNotPrime[i])</span><br><span class="line">	 		isprime[num_prime++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; num_prime &amp;&amp; i * isprime[j] &lt; N; j ++)&#123;</span><br><span class="line">		    isNotPrime[i * isprime[j]] = <span class="number">1</span>;</span><br><span class="line">	  		<span class="keyword">if</span>(!(i % isprime[j]))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="莫筛">莫筛</h2>
<h2 id="code￼11"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span>;   </span><br><span class="line"><span class="keyword">int</span> mu[N], sumu[N];<span class="comment">//莫筛，莫筛前缀和</span></span><br><span class="line"><span class="keyword">int</span> isprime[N/<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;,num_prime = <span class="number">0</span>;    </span><br><span class="line"><span class="keyword">int</span> isNotPrime[N] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mobius</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    sumu[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N ; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(! isNotPrime[i])&#123;</span><br><span class="line">			isprime[num_prime ++]=i;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; num_prime &amp;&amp; i * isprime[j] &lt;  N ; j ++)&#123;               </span><br><span class="line">			isNotPrime[i * isprime[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>( !(i % isprime[j] ) ) <span class="keyword">break</span>;</span><br><span class="line">			mu[isprime[j] * i] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++) sumu[i] = sumu[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2>
<h2 id="欧拉函数">欧拉函数</h2>
<h2 id="code￼12"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span>;</span><br><span class="line"><span class="keyword">int</span> isprime[N/<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;,num_prime = <span class="number">0</span>;<span class="comment">//质数数组，质数数量</span></span><br><span class="line"><span class="keyword">int</span> phi[N];<span class="comment">//欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> isNotPrime[N] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Eular</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!isNotPrime[i])&#123;</span><br><span class="line">	 		isprime[num_prime++]=i;</span><br><span class="line">        	phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num_prime &amp;&amp; i * isprime[j] &lt;  N; j++)&#123;</span><br><span class="line">		    isNotPrime[i * isprime[j]] = <span class="number">1</span>;</span><br><span class="line">	  		<span class="keyword">if</span>(!(i % isprime[j]))&#123;</span><br><span class="line">                phi[i * isprime[j]] = phi[i] * isprime[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                phi[i * isprime[j]] = phi[i] * (isprime[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="求最小因子">求最小因子</h2>
<h2 id="code￼13"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> isprime[maxn/<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;,num_prime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> MinFactor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FindMinFactor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    MinFactor[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!MinFactor[i])&#123;</span><br><span class="line">	 		isprime[num_prime++]=i;</span><br><span class="line">            MinFactor[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i * isprime[j] &lt; n &amp;&amp; j &lt; num_prime; j++)&#123;</span><br><span class="line">            Minfactor[i * isprime[j]] = isprime[j];</span><br><span class="line">	  		<span class="keyword">if</span>(!(i % isprime[j]))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="组合数">组合数</h2>
<h2 id="code￼14"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll F[maxn], Finv[maxn], inv[maxn];<span class="comment">//F是阶乘，Finv是逆元的阶乘 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">comb_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt; maxn; i ++)&#123;</span><br><span class="line">        inv[i] = (mod - mod / i) * <span class="number">1ll</span> * inv[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>] = Finv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt; maxn; i ++)&#123;</span><br><span class="line">        F[i] = F[i<span class="number">-1</span>] * <span class="number">1ll</span> * i % mod;</span><br><span class="line">        Finv[i] = Finv[i<span class="number">-1</span>] * <span class="number">1ll</span> * inv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">comb</span><span class="params">(ll n, ll m)</span></span>&#123;<span class="comment">//comb(n, m)就是C(n, m) </span></span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span> || m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> F[n] * <span class="number">1ll</span> * Finv[n - m] % mod * Finv[m] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="大数除">大数除</h2>
<h2 id="code￼15"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Large_Div</span><span class="params">(<span class="keyword">char</span> Dividend[maxn], ll Divisor)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Divisor &lt; <span class="number">0</span>) &#123;<span class="comment">//除去除数的负号，标记</span></span><br><span class="line">        Divisor = -Divisor;</span><br><span class="line">        jd = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Divisor == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll len = <span class="built_in">strlen</span>(Dividend);</span><br><span class="line">    ll now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dividend[i] == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;<span class="comment">//除去被除数的负号</span></span><br><span class="line">        now = now * <span class="number">10</span> + (Dividend[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ans += now / Divisor;</span><br><span class="line">        now %= Divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Dividend[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(jd ^ (Dividend[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)) ans = -ans;<span class="comment">//如果有一个是负数，结果为负</span></span><br><span class="line">    <span class="keyword">if</span>(now == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="快速幂">快速幂</h2>
<h2 id="code￼16"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PowerMod</span><span class="params">(ll a, ll b, ll c)</span></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	a = a % c;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			ans = ((ans % c) * (a % c)) % c;</span><br><span class="line">		b = b/<span class="number">2</span>;</span><br><span class="line">		a = (a * a) % c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="矩阵快速幂">矩阵快速幂</h2>
<h2 id="code￼17"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">    Mat()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++) a[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll n, k;</span><br><span class="line">Mat <span class="keyword">operator</span> *(<span class="keyword">const</span> Mat &amp;x, <span class="keyword">const</span> Mat &amp;y)&#123;</span><br><span class="line">    Mat z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Mat <span class="title">QuickMod</span><span class="params">(Mat now, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Mat ans;</span><br><span class="line">    ans.build();</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * now;</span><br><span class="line">        now = now * now;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n, &amp;k);</span><br><span class="line">    Mat ans, a;</span><br><span class="line">    a.build();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a.a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    ans = QuickMod(a, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans.a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>数据结构</h1>
<h2 id="线段树">线段树</h2>
<h2 id="code￼18"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> pre, add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;</span><br><span class="line">    t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(p * <span class="number">2</span>, l, mid);</span><br><span class="line">    build(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    t[p].pre = t[p*<span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p*<span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre += (ll)num * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += num;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) change(p * <span class="number">2</span>, l, r, num);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) change(p * <span class="number">2</span> + <span class="number">1</span>, l, r, num);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) ans += search(p * <span class="number">2</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) ans += search(p * <span class="number">2</span> + <span class="number">1</span>, l , r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">int</span> l, r, num;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;num;</span><br><span class="line">            change(<span class="number">1</span>, l, r, num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(search(<span class="number">1</span>, l, r));</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="ST表">ST表</h2>
<h2 id="code￼19"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> lg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">21</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n;i++)&#123;</span><br><span class="line">            f[i][j] = max(f[i][j<span class="number">-1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lg[r - l + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(f[l][mid], f[r - (<span class="number">1</span> &lt;&lt; mid) + <span class="number">1</span>][mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i][<span class="number">0</span>]);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="Trie树">Trie树</h2>
<h2 id="code￼20"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">26</span>];</span><br><span class="line">&#125;trie[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, root[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = str.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(trie[now].son[str[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            trie[now].son[str[i]-<span class="string">&#x27;a&#x27;</span>] = ++cnt;<span class="comment">//动态开点</span></span><br><span class="line">        &#125;</span><br><span class="line">        now = trie[now].son[str[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    root[now] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = str.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">        now = trie[now].son[str[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        insert(str,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;search(str)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="主席树">主席树</h2>
<h2 id="code￼21"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum;</span><br><span class="line">&#125;hjt[maxn*<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, root[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(v.begin(),v.end(),x) - v.begin() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pre, <span class="keyword">int</span> &amp;now, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    hjt[++cnt] = hjt[pre];</span><br><span class="line">    now = cnt;</span><br><span class="line">    hjt[now].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid)&#123;</span><br><span class="line">        insert(l, mid, hjt[pre].l, hjt[now].l, p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(mid + <span class="number">1</span>, r, hjt[pre].r, hjt[now].r, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = hjt[hjt[R].l].sum - hjt[hjt[L].l].sum;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= temp)&#123;</span><br><span class="line">        <span class="keyword">return</span> query(l, mid, hjt[L].l, hjt[R].l, k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(mid + <span class="number">1</span>, r, hjt[L].r, hjt[R].r, k - temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">        v.push_back(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    v.erase(unique(v.begin(),v.end()), v.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        insert(<span class="number">1</span>, n, root[i<span class="number">-1</span>], root[i], getid(num[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[query(<span class="number">1</span>, n, root[l<span class="number">-1</span>], root[r], k) - <span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h2 id="树状数组">树状数组</h2>
<h2 id="code￼22"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x &amp; -x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;pos &lt;= n;pos += lowbit(pos))&#123;</span><br><span class="line">        t[pos] += p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    change(p, l, n);</span><br><span class="line">    change(-p, r+<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">search</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos;pos -= lowbit(pos))&#123;</span><br><span class="line">        sum += t[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_ans1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> search(r) - search(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_ans2</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos;pos -= lowbit(pos)) ans+= t[pos];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll num;</span><br><span class="line">    ll last;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;last;</span><br><span class="line">    change(last, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">        change(num - last, i, n);</span><br><span class="line">        last = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ord;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ord;</span><br><span class="line">        <span class="keyword">if</span>(ord == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            ll k;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">            update(l, r, k, n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;pos;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;get_ans2(pos)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h1>字符串</h1>
<h2 id="kmp">kmp</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> text = <span class="string">&quot;aaaaabbb&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> pattern[<span class="number">6</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    j = <span class="number">-1</span>, i = <span class="number">0</span>;</span><br><span class="line">    next[i] = j;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) j = next[j];</span><br><span class="line">        i++, j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++) <span class="built_in">cout</span>&lt;&lt;next[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    j = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; text.length())&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] != text[i]) j = next[j];</span><br><span class="line">        i++, j++;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">6</span>)&#123;</span><br><span class="line">            ans = i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>模板</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://crotes.top/2021/10/22/%E6%A8%A1%E6%9D%BF/">http://crotes.top/2021/10/22/模板/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Crotes</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-10-22</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2022-04-04</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ACM/">ACM</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/31/CUIT%E6%96%B0%E7%94%9F%E6%B5%8B%E8%AF%95%E8%B5%9B/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CUIT新生测试赛</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/11/dp/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">dp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/31/CUIT新生测试赛/" title="CUIT新生测试赛"><img class="cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-04-04</div><div class="title">CUIT新生测试赛</div></div></a></div><div><a href="/2021/07/14/math/" title="math"><img class="cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-04-04</div><div class="title">math</div></div></a></div><div><a href="/2021/04/11/图/" title="图"><img class="cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-04-04</div><div class="title">图</div></div></a></div><div><a href="/2021/04/15/树/" title="树"><img class="cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-04-04</div><div class="title">树</div></div></a></div><div><a href="/2021/01/22/算法/" title="算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/Crotes/jsd/pic/002.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-04-04</div><div class="title">算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dijstra"><span class="toc-number">1.1.1.</span> <span class="toc-text">dijstra</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC0"><span class="toc-number">1.2.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
#define ll long long
#define int ll
#define INF 0x3f
typedef pair&lt;int, int&gt; PII;
const int maxn &#x3D; 1e5 + 5;
const int maxm &#x3D; 5e5 + 5;
struct node&amp;#123;
    int to;
    int w;
    int next;
&amp;#125;edge[maxm];
int head[maxn], cnt;
inline void add(int u, int v, int w)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].w &#x3D; w;
    edge[cnt].next &#x3D; head[u];
    head[u] &#x3D; cnt;
&amp;#125;
int dis[maxn];
bool vis[maxn];
&#x2F;&#x2F;普通dijstra
inline void dijstra1(int st, int n)&amp;#123;
    memset(dis, INF, sizeof(dis));
    dis[st] &#x3D; 0;
    for(int i &#x3D; 0;i &lt; n;i++)&amp;#123;
        int u &#x3D; -1, min &#x3D; dis[0];
        for(int j &#x3D; 1;j &lt;&#x3D; n;j++)&amp;#123;
            if(vis[j] &#x3D;&#x3D; false &amp;&amp; dis[j] &lt; min)&amp;#123;
                u &#x3D; j;
                min &#x3D; dis[j];
            &amp;#125;
        &amp;#125;
        if(u &#x3D;&#x3D; -1) break;
        vis[u] &#x3D; true;
        for(int i &#x3D; head[u];i;i &#x3D; edge[i].next)&amp;#123;
            if(vis[edge[i].to] &#x3D;&#x3D; false &amp;&amp; dis[edge[i].to] &gt; dis[u] + edge[i].w)&amp;#123;
                dis[edge[i].to] &#x3D; dis[u] + edge[i].w;
            &amp;#125;
        &amp;#125;
    &amp;#125;

&amp;#125;
&#x2F;&#x2F;堆优化之后的dijstra
inline void dijstra(int st, int n)&amp;#123;
    memset(dis, INF, sizeof(dis));
    dis[st] &#x3D; 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;
    heap.push(&amp;#123;0, st&amp;#125;);
    PII t;
    while(!heap.empty())&amp;#123;
        t &#x3D; heap.top();
        heap.pop();
        int now &#x3D; t.second, distance &#x3D; t.first;
        if(vis[now]) continue;
        vis[now] &#x3D; true;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(dis[edge[i].to] &gt; dis[now] + edge[i].w)&amp;#123;
                dis[edge[i].to] &#x3D; dis[now] + edge[i].w;
                heap.push(&amp;#123;dis[edge[i].to], edge[i].to&amp;#125;);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
signed main(void)&amp;#123;
    int n, m, st;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;st;
    for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
        int u, v, w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add(u, v, w);
        if(u &#x3D;&#x3D; st) dis[v] &#x3D; w;
    &amp;#125;
    dijstra(st, n);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        if(dis[i] &#x3D;&#x3D; dis[0]) cout&lt;&lt;(2147483647);
        else cout&lt;&lt;(dis[i]);
        putchar(&amp;#x27; &amp;#x27;);
    &amp;#125;
    return 0;
&amp;#125;
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spfa"><span class="toc-number">1.2.1.</span> <span class="toc-text">spfa</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC1"><span class="toc-number">1.3.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
#define ll long long
#define int ll
#define INF 0x3f
const int maxn &#x3D; 1e5+5;
const int maxm &#x3D; 5e5+5;
const int inf &#x3D; 2147483647;
struct node&amp;#123;
    int to;
    int next;
    ll w;
&amp;#125;edge[maxm];
int head[maxn], cnt;
inline void add(int u, int v, ll w)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].w &#x3D; w;
    edge[cnt].next &#x3D; head[u];
    head[u] &#x3D; cnt;
&amp;#125;
bool vis[maxn];
ll dis[maxn];
int num_cnt[maxn];
&#x2F;&#x2F; SLF优化后的spfa
inline int spfa1(int st, int aim, int n)&amp;#123;
    memset(dis, INF, sizeof(dis));
    dis[st] &#x3D; 0;
    deque&lt;int&gt; que;
    que.push_back(st);
    vis[st] &#x3D; 1;
    int now;
    num_cnt[st] &#x3D; 1;
    int flag &#x3D; 1;
    while(!que.empty())&amp;#123;
        now &#x3D; que.front();
        que.pop_front();
        vis[now] &#x3D; 0;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(dis[now] + edge[i].w &lt; dis[edge[i].to])&amp;#123;
                dis[edge[i].to] &#x3D; dis[now] + edge[i].w;
                num_cnt[edge[i].to] &#x3D; num_cnt[now] + 1;
                if(num_cnt[edge[i].to] &gt; n) flag &#x3D; 0;
                if(!vis[edge[i].to])&amp;#123;
                    if(!que.empty() &amp;&amp; dis[edge[i].to] &gt;&#x3D; dis[que.front()]) que.push_back(edge[i].to);
                    else que.push_front(edge[i].to);
                    vis[edge[i].to] &#x3D; 1;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return flag;
&amp;#125;
&#x2F;&#x2F; LLL优化后spfa
inline int spfa2(int st, int aim, int n)&amp;#123;
    queue&lt;int&gt; que;
    memset(dis, INF, sizeof(dis));
    que.push(st);
    vis[st] &#x3D; true;
    dis[st] &#x3D; 0;
    int num &#x3D; 1;
    int sum &#x3D; 0;
    num_cnt[st] &#x3D; 1;
    int flag &#x3D; 1;
    while(!que.empty())&amp;#123;
        int now &#x3D; que.front();
        while(dis[now] * num &gt; sum)&amp;#123;
            que.pop();
            que.push(now);
            now &#x3D; que.front();
        &amp;#125;
        que.pop();
        num--;
        sum -&#x3D; dis[now];
        vis[now] &#x3D; false;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(dis[edge[i].to] &gt; dis[now] + edge[i].w)&amp;#123;
                dis[edge[i].to] &#x3D; dis[now] + edge[i].w;
                num_cnt[edge[i].to] &#x3D; num_cnt[now] + 1;
                if(num_cnt[edge[i].to] &gt; n) flag &#x3D; 0;
                if(!vis[edge[i].to])&amp;#123;
                    que.push(edge[i].to);
                    sum +&#x3D; dis[edge[i].to];
                    num++;
                    vis[edge[i].to] &#x3D; 1;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return flag;
&amp;#125;
&#x2F;&#x2F; LLL+SLF优化
inline int spfa(int st, int aim, int n)&amp;#123;
    memset(dis, INF, sizeof(dis));
    deque&lt;int&gt; que;
    que.push_back(st);
    vis[st] &#x3D; true;
    dis[st] &#x3D; 0;
    int num &#x3D; 1;
    int sum &#x3D; 0;
    num_cnt[st] &#x3D; 1;
    int flag &#x3D; 1;
    while(!que.empty())&amp;#123;
        int now &#x3D; que.front();
        while(num * dis[now] &gt; sum)&amp;#123;
            que.pop_front();
            que.push_back(now);
            now &#x3D; que.front();
        &amp;#125;
        que.pop_front();
        num--;
        sum -&#x3D; dis[now];
        vis[now] &#x3D; false;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(dis[edge[i].to] &gt; dis[now] + edge[i].w)&amp;#123;
                dis[edge[i].to] &#x3D; dis[now] + edge[i].w;
                num_cnt[edge[i].to] &#x3D; num_cnt[now] + 1;
                if(num_cnt[edge[i].to] &gt; n) flag &#x3D; 0;
                if(!vis[edge[i].to])&amp;#123;
                    if(!que.empty() &amp;&amp;(dis[edge[i].to] &lt;&#x3D; dis[que.front()])) que.push_front(edge[i].to);
                    else que.push_back(edge[i].to);
                    vis[edge[i].to] &#x3D; true;
                    sum +&#x3D; dis[edge[i].to];
                    num++;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return flag;
&amp;#125;
signed main(void)&amp;#123;
    int n, m, s;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
        int u, v;
        ll w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add(u, v, w);
    &amp;#125;
    spfa(s, 0, n);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        if(dis[i] &#x3D;&#x3D; dis[0]) cout&lt;&lt;(inf);
        else cout&lt;&lt;(dis[i]);
        putchar(&amp;#x27; &amp;#x27;);
    &amp;#125;
    return 0;
&amp;#125;
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#floyd"><span class="toc-number">1.3.1.</span> <span class="toc-text">floyd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC2"><span class="toc-number">1.4.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ll long long
#define INF 0x3f
const int maxn &#x3D; 505;
ll dis[maxn][maxn];
inline void floyd(int n)&amp;#123;
    for(int k &#x3D; 1;k &lt;&#x3D; n;k++)&amp;#123;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
            if(dis[i][k] &#x3D;&#x3D; dis[0][0]) continue;
            for(int j &#x3D; 1;j &lt;&#x3D; i;j++)&amp;#123;
                dis[i][j] &#x3D; min(dis[i][j], (dis[i][k] + dis[k][j]));
                dis[j][i] &#x3D; dis[i][j];
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
signed main(void)&amp;#123;
    int n, m;
    while(1)&amp;#123;
        cin&gt;&gt;n&gt;&gt;m;
        if(n &#x3D;&#x3D; 0 &amp;&amp; m &#x3D;&#x3D; 0) break;
        memset(dis, INF, sizeof(dis));
        for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
            int u, v, w;
            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
            dis[u][v] &#x3D; dis[v][u] &#x3D; w;
        &amp;#125;
        floyd(n);
        cout&lt;&lt;dis[1][n]&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#johnson"><span class="toc-number">1.4.1.</span> <span class="toc-text">johnson</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC3"><span class="toc-number">1.5.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;deque&gt;
using namespace std;
#define ll long long
#define int ll
#define INF 0x3f
typedef pair&lt;int, int&gt; PII;
const int maxn &#x3D; 1e3 + 5;
const int maxm &#x3D; 1e5 + 5;
const int maxl &#x3D; 1e9;
struct node&amp;#123;
    int to;
    int w;
    int next;
&amp;#125;edge[maxm&lt;&lt;1];
int head[maxn], cnt;
inline void add(int u, int v, int w)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].w &#x3D; w;
    edge[cnt].next &#x3D; head[u];
    head[u] &#x3D; cnt;
&amp;#125;
int dis[maxn];
int vis[maxn];
inline void dijstra(int st, int aim, int n)&amp;#123;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) dis[i] &#x3D; maxl;
    memset(vis, 0, sizeof(vis));
    dis[st] &#x3D; 0;
    heap.push(PII(0, st));
    PII t;
    while(!heap.empty())&amp;#123;
        t &#x3D; heap.top();
        heap.pop();
        int now &#x3D; t.second;
        if(vis[now]) continue;
        vis[now] &#x3D; 1;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(dis[edge[i].to] &gt; dis[now] + edge[i].w)&amp;#123;
                dis[edge[i].to] &#x3D; dis[now] + edge[i].w;
                heap.push(PII(dis[edge[i].to], edge[i].to));
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
int h[maxn];
int num_cnt[maxn];
inline int spfa(int st, int aim, int n)&amp;#123;
    memset(vis, 0, sizeof(vis));
    memset(h, INF, sizeof(h));
    deque&lt;int&gt; que;
    que.push_back(st);
    vis[st] &#x3D; 1;
    h[st] &#x3D; 0;
    num_cnt[st] &#x3D; 1;
    int num &#x3D; 1;
    int sum &#x3D; 0;
    while(!que.empty())&amp;#123;
        int now &#x3D; que.front();
        while(num * h[now] &gt; sum)&amp;#123;
            que.pop_front();
            que.push_back(now);
            now &#x3D; que.front();
        &amp;#125;
        que.pop_front();
        num--;
        sum -&#x3D; h[now];
        vis[now] &#x3D; 0;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(h[edge[i].to] &gt; h[now] + edge[i].w)&amp;#123;
                h[edge[i].to] &#x3D; h[now] + edge[i].w;
                num_cnt[edge[i].to] &#x3D; num_cnt[now] + 1;
                if(num_cnt[edge[i].to] &gt; n) return 0;;
                if(!vis[edge[i].to])&amp;#123;
                    if(!que.empty() &amp;&amp; (h[edge[i].to] &lt;&#x3D; h[que.front()])) que.push_front(edge[i].to);
                    else que.push_back(edge[i].to);
                    vis[edge[i].to] &#x3D; 1;
                    sum +&#x3D; h[edge[i].to];
                    num++; 
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 1;
&amp;#125;
signed main(void)&amp;#123;
    int n, m;
    while(1)&amp;#123;
        cnt &#x3D; 0;
        memset(head, 0, sizeof(head));
        cin&gt;&gt;n&gt;&gt;m;
        if(!n &amp;&amp; !m) break;
        for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&amp;#123;
            int u, v, w;
            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
            add(u, v, w);
            add(v, u, w);
        &amp;#125;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
            add(0, i, 0);
        &amp;#125;
        spfa(0, 1, n);
        for(int now &#x3D; 1;now &lt;&#x3D; n;now++)&amp;#123;
            for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
                edge[i].w +&#x3D; h[now] - h[edge[i].to];
            &amp;#125;
        &amp;#125;
        dijstra(1, n, n);
        cout&lt;&lt;dis[n]&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%ACK%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.6.</span> <span class="toc-text">第K短路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC4"><span class="toc-number">1.7.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
#define INF 0x3f
typedef pair&lt;int, int&gt; PII;
const int maxn &#x3D; 1000+50;
const int maxm &#x3D; 100000 + 50;
struct Edge&amp;#123;
    int to, w, next;
&amp;#125;edge[maxm&lt;&lt;1];
int headz[maxn], cnt;
int headf[maxn];
struct node&amp;#123;
    int f, g, from;
    bool operator &lt; (node a) const&amp;#123;
        if(a.f &#x3D;&#x3D; f) return g&gt;a.g;
        return f&gt;a.f;
    &amp;#125;
&amp;#125;;
inline void add1(int u, int v, int w)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].w &#x3D; w;
    edge[cnt].next &#x3D; headz[u];
    headz[u] &#x3D; cnt;
&amp;#125;
inline void add2(int u, int v, int w)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].w &#x3D; w;
    edge[cnt].next &#x3D; headf[u];
    headf[u] &#x3D; cnt;
&amp;#125;
int h[maxn];
bool vis[maxn];
inline int dijstra(int st, int ed, int n)&amp;#123;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;
    memset(h, INF, sizeof(h));
    memset(vis, 0, sizeof(vis));
    PII t;
    int now;
    h[st] &#x3D; 0;
    q.push(PII(h[st], st));
    while(!q.empty())&amp;#123;
        t &#x3D; q.top();
        q.pop();
        now &#x3D; t.second;
        if(vis[now]) continue;
        vis[now] &#x3D; 1;
        for(int i &#x3D; headf[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(h[edge[i].to] &gt; h[now] + edge[i].w)&amp;#123;
                h[edge[i].to] &#x3D; h[now] + edge[i].w;
                q.push(PII(h[edge[i].to], edge[i].to));
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
inline int AStar(int st, int ed, int k)&amp;#123;
    if(st &#x3D;&#x3D; ed) k++;
    if(h[st] &#x3D;&#x3D; h[0]) return -1;
    priority_queue&lt;node&gt; q;
    int cnt &#x3D; 0;
    node tmp, to;
    tmp.from &#x3D; st;
    tmp.g &#x3D; 0;
    tmp.f &#x3D; tmp.g + h[tmp.from];
    q.push(tmp);
    while(!q.empty())&amp;#123;
        tmp &#x3D; q.top();
        q.pop();
        if(tmp.from &#x3D;&#x3D; ed) cnt++;
        if(cnt &#x3D;&#x3D; k) return tmp.g;  
        for(int i &#x3D; headz[tmp.from];i;i &#x3D; edge[i].next)&amp;#123;
            to.from &#x3D; edge[i].to;
            to.g &#x3D; tmp.g + edge[i].w;
            to.f &#x3D; to.g + h[to.from];
            q.push(to);
        &amp;#125;
    &amp;#125;
    return -1;
&amp;#125;
inline void init(void)&amp;#123;
    memset(headf, 0, sizeof(headf));
    memset(headz, 0, sizeof(headz));
    cnt &#x3D; 0;
&amp;#125;
int main(void)&amp;#123;
    int n, m;
    int u, v, w;
    while(cin&gt;&gt;n&gt;&gt;m)&amp;#123;
        init();
        for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
            add1(u, v, w);
            add2(v, u, w);
        &amp;#125;
        int s, t, k;
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;k;
        dijstra(t, s, n);
        cout&lt;&lt;AStar(s, t, k)&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.8.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prim"><span class="toc-number">1.8.1.</span> <span class="toc-text">prim</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC5"><span class="toc-number">1.9.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn &#x3D; 5e3 + 4;
const int maxm &#x3D; 2e5 + 5;
const int inf &#x3D; 0x7ffffff;
struct node&amp;#123;
    int to, w, next;
&amp;#125;edge[maxm&lt;&lt;1];
int head[maxn], cnt;
inline void add(int u, int v, int w)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].w &#x3D; w;
    edge[cnt].next &#x3D; head[u];
    head[u] &#x3D; cnt;
&amp;#125;
int tot, now, ans, dis[maxn],vis[maxn];
int n, m;
int jd;
inline int prim(void)&amp;#123;
    now &#x3D; 1;
    for(int i &#x3D; 2;i &lt;&#x3D; n;i++)&amp;#123;  
        dis[i] &#x3D; inf;
    &amp;#125;
    for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
        dis[edge[i].to] &#x3D; min(dis[edge[i].to], edge[i].w);
    &amp;#125;
    while(++tot &lt; n)&amp;#123;
        jd &#x3D; 0;
        int minn &#x3D; inf;
        vis[now] &#x3D; 1;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
            if(!vis[i] &amp;&amp; minn &gt; dis[i])&amp;#123;
                minn &#x3D; dis[i];
                now &#x3D; i;
                jd &#x3D; 1;
            &amp;#125;
        &amp;#125;
        if(!jd) return 0;
        ans +&#x3D; minn;
        for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
            if(!vis[edge[i].to])
            dis[edge[i].to] &#x3D; min(dis[edge[i].to], edge[i].w);
        &amp;#125;
    &amp;#125;
    return ans;
&amp;#125;
signed main(void)&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
        int u, v, w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add(u, v, w);
        add(v, u, w);
    &amp;#125;
    prim();
    if(jd) cout&lt;&lt;ans;
    else cout&lt;&lt;&quot;orz&quot;;
    return 0;
&amp;#125;
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KrusKal"><span class="toc-number">1.9.1.</span> <span class="toc-text">KrusKal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC6"><span class="toc-number">1.10.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn &#x3D; 5e3 + 5;
const int maxm &#x3D; 4e5 + 5;
int id[maxn];
inline void init(int n)&amp;#123;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) id[i] &#x3D; i;
&amp;#125;
inline int find(int p)&amp;#123;
    if(p &#x3D;&#x3D; id[p]) return p;
    return id[p] &#x3D; find(id[p]);
&amp;#125;
struct edge&amp;#123;
    int from, to, w;   
&amp;#125;edge[maxm];
inline int cmp(struct edge p, struct edge q)&amp;#123;
    return p.w &lt; q.w;
&amp;#125;
int n, m;
int ans, tot;
inline void kruskal(void)&amp;#123;
    sort(edge, edge + m, cmp);
    for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
        int rootp &#x3D; find(edge[i].from);
        int rootq &#x3D; find(edge[i].to);
        if(rootq &#x3D;&#x3D; rootp) continue;
        ans +&#x3D; edge[i].w;
        id[rootq] &#x3D; rootp;
        if(++tot &#x3D;&#x3D; n-1) break;
    &amp;#125;
&amp;#125;
signed main(void)&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    init(n);
    for(int i &#x3D; 0;i &lt; m;i++)&amp;#123;
        cin&gt;&gt;edge[i].from&gt;&gt;edge[i].to&gt;&gt;edge[i].w;
    &amp;#125;
    kruskal();
    if(tot &#x3D;&#x3D; n-1) cout&lt;&lt;ans;
    else cout&lt;&lt;&quot;orz&quot;;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lca"><span class="toc-number">1.11.</span> <span class="toc-text">lca</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC7"><span class="toc-number">1.12.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn &#x3D; 5e5 + 5;
struct edge&amp;#123;
    int to;
    int next;
&amp;#125;edge[maxn &lt;&lt; 1];
int head[maxn], cnt;
void add(int x, int y)&amp;#123;
    edge[++cnt].to &#x3D; y;
    edge[cnt].next &#x3D; head[x];
    head[x] &#x3D; cnt;
&amp;#125;
int depth[maxn], fa[maxn][21], lg[maxn];
void dfs(int now, int fath)&amp;#123;
    fa[now][0] &#x3D; fath;
    depth[now] &#x3D; depth[fath] + 1;
    for(int i &#x3D; 1;i &lt; lg[depth[now]];i++)&amp;#123;
        fa[now][i] &#x3D; fa[fa[now][i-1]][i-1];
    &amp;#125;   
    for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
        if(edge[i].to !&#x3D; fath) dfs(edge[i].to, now);
    &amp;#125;
&amp;#125;
int lca(int x, int y)&amp;#123;
    if(depth[x] &lt; depth[y]) swap(x, y);
    while(depth[x] &gt; depth[y])&amp;#123;
        x &#x3D; fa[x][lg[depth[x] - depth[y]] - 1];
    &amp;#125;
    if(x &#x3D;&#x3D; y) return x;
    for(int k &#x3D; lg[depth[x] - 1];k &gt;&#x3D; 0;k--)&amp;#123;
        if(fa[x][k] !&#x3D; fa[y][k])&amp;#123;
            x &#x3D; fa[x][k];
            y &#x3D; fa[y][k];
        &amp;#125;
    &amp;#125;
    return fa[x][0];
&amp;#125;
int main(void)&amp;#123;
    int n, m, s;
    scanf(&quot;%d %d %d&quot;,&amp;n, &amp;m, &amp;s);
    for(int i &#x3D; 1;i &lt; n;i++)&amp;#123;
        int x, y;
        scanf(&quot;%d %d&quot;,&amp;x, &amp;y);
        add(x, y);
        add(y, x);
    &amp;#125;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        lg[i] &#x3D; lg[i-1] + (1 &lt;&lt; lg[i-1] &#x3D;&#x3D; i);
    &amp;#125;
    dfs(s,0);
    for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&amp;#123;
        int x, y;
        scanf(&quot;%d %d&quot;,&amp;x, &amp;y);
        printf(&quot;%d\n&quot;,lca(x, y));
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.13.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.13.1.</span> <span class="toc-text">匈牙利算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC8"><span class="toc-number">1.14.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxm &#x3D; 1000050;
const int maxn &#x3D; 1050;
struct node&amp;#123;
    int to, next;
&amp;#125;edge[maxm];
int flag[maxn][maxn];
int head[maxn], cnt;
inline void add(int u, int v)&amp;#123;
    edge[++cnt].to &#x3D; v;
    edge[cnt].next &#x3D; head[u];
    head[u] &#x3D; cnt;
&amp;#125;
int id[maxn];&#x2F;&#x2F;原配
int vis[maxn];
inline int dfs(int now)&amp;#123;
    for(int i &#x3D; head[now];i;i &#x3D; edge[i].next)&amp;#123;
        if(!vis[edge[i].to])&amp;#123;
            vis[edge[i].to] &#x3D; 1;
            if(!id[edge[i].to] || dfs(id[edge[i].to]))&amp;#123;
                id[edge[i].to] &#x3D; now;
                return 1;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
inline int hungarian(int n)&amp;#123;
    int ans;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        memset(vis, 0, sizeof(vis));
        if(dfs(i)) ans++;
    &amp;#125;
    return ans;
&amp;#125;
signed main(void)&amp;#123;
    int n, m, e;
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;e);
    int u, v;
    for(int i &#x3D; 0;i &lt; e;i++)&amp;#123;
        scanf(&quot;%d %d&quot;,&amp;u, &amp;v);
        if(!flag[u][v])
        add(u, v),flag[u][v] &#x3D; 1;
    &amp;#125;
    printf(&quot;%d&quot;, hungarian(n));
    return 0;
&amp;#125;
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gcd"><span class="toc-number">2.1.</span> <span class="toc-text">gcd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC9"><span class="toc-number">2.2.</span> <span class="toc-text">1
2
3
4
5
6
inline ll gcd(ll a, ll b)&amp;#123;
    if (b &#x3D;&#x3D; 0)
        return a;
    else
        return gcd(b, a % b);
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E7%AD%9B"><span class="toc-number">2.3.</span> <span class="toc-text">欧拉筛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC10"><span class="toc-number">2.4.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
const int N &#x3D; 200000;
int isprime[N&#x2F;3] &#x3D; &amp;#123;0&amp;#125;,num_prime &#x3D; 0;&#x2F;&#x2F;质数数组，质数数量
bool isNotPrime[N] &#x3D; &amp;#123;1, 1&amp;#125;;
inline void prime(void)&amp;#123;
     for(int i &#x3D; 2 ; i &lt; N ; i ++)&amp;#123;
		if(!isNotPrime[i])
	 		isprime[num_prime++]&#x3D;i;
		for(int j &#x3D; 0 ; j &lt; num_prime &amp;&amp; i * isprime[j] &lt; N; j ++)&amp;#123;
		    isNotPrime[i * isprime[j]] &#x3D; 1;
	  		if(!(i % isprime[j]))
				break;
		&amp;#125;
	&amp;#125;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%AB%E7%AD%9B"><span class="toc-number">2.5.</span> <span class="toc-text">莫筛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC11"><span class="toc-number">2.6.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
const int N &#x3D; 200000;   
int mu[N], sumu[N];&#x2F;&#x2F;莫筛，莫筛前缀和
int isprime[N&#x2F;3] &#x3D; &amp;#123;0&amp;#125;,num_prime &#x3D; 0;    
int isNotPrime[N] &#x3D; &amp;#123;1, 1&amp;#125;;   
inline void mobius(void)&amp;#123;
    sumu[1] &#x3D; mu[1] &#x3D; 1;
	for(int i &#x3D; 2 ; i &lt; N ; i ++)&amp;#123;
		if(! isNotPrime[i])&amp;#123;
			isprime[num_prime ++]&#x3D;i;
			mu[i] &#x3D; -1;
		&amp;#125;
		for(int j &#x3D; 0 ; j &lt; num_prime &amp;&amp; i * isprime[j] &lt;  N ; j ++)&amp;#123;               
			isNotPrime[i * isprime[j]] &#x3D; 1;
			if( !(i % isprime[j] ) ) break;
			mu[isprime[j] * i] &#x3D; -mu[i];
		&amp;#125;
	&amp;#125;
    for(int i &#x3D; 2;i &lt; N;i++) sumu[i] &#x3D; sumu[i-1] + mu[i];
&amp;#125; 
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">欧拉函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC12"><span class="toc-number">2.8.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
const int N &#x3D; 200000;
int isprime[N&#x2F;3] &#x3D; &amp;#123;0&amp;#125;,num_prime &#x3D; 0;&#x2F;&#x2F;质数数组，质数数量
int phi[N];&#x2F;&#x2F;欧拉函数
bool isNotPrime[N] &#x3D; &amp;#123;1, 1&amp;#125;;
inline void Eular(void)&amp;#123;
    phi[1] &#x3D; 1;
	for(int i &#x3D; 2; i &lt; N; i++)&amp;#123;
		if(!isNotPrime[i])&amp;#123;
	 		isprime[num_prime++]&#x3D;i;
        	phi[i] &#x3D; i - 1;
        &amp;#125;
		for(int j &#x3D; 0; j &lt; num_prime &amp;&amp; i * isprime[j] &lt;  N; j++)&amp;#123;
		    isNotPrime[i * isprime[j]] &#x3D; 1;
	  		if(!(i % isprime[j]))&amp;#123;
                phi[i * isprime[j]] &#x3D; phi[i] * isprime[j];
				break;
            &amp;#125;else
                phi[i * isprime[j]] &#x3D; phi[i] * (isprime[j] - 1);
		&amp;#125;
	&amp;#125;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E5%B0%8F%E5%9B%A0%E5%AD%90"><span class="toc-number">2.9.</span> <span class="toc-text">求最小因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC13"><span class="toc-number">2.10.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
const int maxn &#x3D; 1e7+5;
int isprime[maxn&#x2F;3] &#x3D; &amp;#123;0&amp;#125;,num_prime &#x3D; 0;
int MinFactor[maxn];
inline void FindMinFactor(int n)&amp;#123;
    MinFactor[1] &#x3D; 1;
    for(int i &#x3D; 2; i &lt; n; i++)&amp;#123;
		if(!MinFactor[i])&amp;#123;
	 		isprime[num_prime++]&#x3D;i;
            MinFactor[i] &#x3D; i;
        &amp;#125;
		for(int j &#x3D; 0; i * isprime[j] &lt; n &amp;&amp; j &lt; num_prime; j++)&amp;#123;
            Minfactor[i * isprime[j]] &#x3D; isprime[j];
	  		if(!(i % isprime[j]))
				break;
		&amp;#125;
	&amp;#125;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">组合数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC14"><span class="toc-number">2.12.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
const int maxn &#x3D; 200000 + 5;
const int mod &#x3D; (int)1e9 + 7;
ll F[maxn], Finv[maxn], inv[maxn];&#x2F;&#x2F;F是阶乘，Finv是逆元的阶乘 
inline void comb_init()&amp;#123;
    inv[1] &#x3D; 1;
    for(ll i &#x3D; 2; i &lt; maxn; i ++)&amp;#123;
        inv[i] &#x3D; (mod - mod &#x2F; i) * 1ll * inv[mod % i] % mod;
    &amp;#125;
    F[0] &#x3D; Finv[0] &#x3D; 1;
    for(ll i &#x3D; 1; i &lt; maxn; i ++)&amp;#123;
        F[i] &#x3D; F[i-1] * 1ll * i % mod;
        Finv[i] &#x3D; Finv[i-1] * 1ll * inv[i] % mod;
    &amp;#125;
&amp;#125;
inline ll comb(ll n, ll m)&amp;#123;&#x2F;&#x2F;comb(n, m)就是C(n, m) 
    if(m &lt; 0 || m &gt; n) return 0;
    return F[n] * 1ll * Finv[n - m] % mod * Finv[m] % mod;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E9%99%A4"><span class="toc-number">2.13.</span> <span class="toc-text">大数除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC15"><span class="toc-number">2.14.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
inline int Large_Div(char Dividend[maxn], ll Divisor)&amp;#123;
    ll ans &#x3D; 0;
    int jd &#x3D; 0;
    if(Divisor &lt; 0) &amp;#123;&#x2F;&#x2F;除去除数的负号，标记
        Divisor &#x3D; -Divisor;
        jd &#x3D; 1;
    &amp;#125;
    if(Divisor &#x3D;&#x3D; 0) return 0;
    ll len &#x3D; strlen(Dividend);
    ll now &#x3D; 0;
    for(ll i &#x3D; 0;i &lt; len;i++)&amp;#123;
        if(Dividend[i] &#x3D;&#x3D; &amp;#x27;-&amp;#x27;) continue;&#x2F;&#x2F;除去被除数的负号
        now &#x3D; now * 10 + (Dividend[i] - &amp;#x27;0&amp;#x27;);
        ans +&#x3D; now &#x2F; Divisor;
        now %&#x3D; Divisor;
    &amp;#125;
    if(Dividend[0] &#x3D;&#x3D; &amp;#x27;0&amp;#x27;) return -1;
    if(jd ^ (Dividend[0] &#x3D;&#x3D; &amp;#x27;-&amp;#x27;)) ans &#x3D; -ans;&#x2F;&#x2F;如果有一个是负数，结果为负
    if(now &#x3D;&#x3D; 0) return ans;
    else return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">2.15.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC16"><span class="toc-number">2.16.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
inline ll PowerMod(ll a, ll b, ll c)&amp;#123;
	ll ans &#x3D; 1;
	a &#x3D; a % c;
	while(b&gt;0)&amp;#123;
		if(b % 2 &#x3D;&#x3D; 1)
			ans &#x3D; ((ans % c) * (a % c)) % c;
		b &#x3D; b&#x2F;2;
		a &#x3D; (a * a) % c;
	&amp;#125;
	return ans;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">2.17.</span> <span class="toc-text">矩阵快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC17"><span class="toc-number">2.18.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
#define ll long long
#define int ll
const int maxn &#x3D; 105;
const ll mod &#x3D; 1e9 + 7;
struct Mat&amp;#123;
    ll a[maxn][maxn];
    Mat()&amp;#123;
        memset(a, 0, sizeof(a));
    &amp;#125;
    inline void build()&amp;#123;
        for(int i &#x3D; 1;i &lt; maxn;i++) a[i][i] &#x3D; 1;
    &amp;#125;
&amp;#125;;
ll n, k;
Mat operator *(const Mat &amp;x, const Mat &amp;y)&amp;#123;
    Mat z;
    for(int k &#x3D; 1;k &lt;&#x3D; n;k++)&amp;#123;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
            for(int j &#x3D; 1;j &lt;&#x3D; n;j++)&amp;#123;
                z.a[i][j] &#x3D; (z.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return z;
&amp;#125;
inline Mat QuickMod(Mat now, int k)&amp;#123;
    Mat ans;
    ans.build();
    while(k)&amp;#123;
        if(k &amp; 1) ans &#x3D; ans * now;
        now &#x3D; now * now;
        k &gt;&gt;&#x3D; 1;
    &amp;#125;
    return ans;
&amp;#125;
signed main(void)&amp;#123;
    scanf(&quot;%lld %lld&quot;,&amp;n, &amp;k);
    Mat ans, a;
    a.build();
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        for(int j &#x3D; 1;j &lt;&#x3D; n;j++)&amp;#123;
            scanf(&quot;%lld&quot;, &amp;a.a[i][j]);
        &amp;#125;
    &amp;#125;   
    ans &#x3D; QuickMod(a, k);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        for(int j &#x3D; 1;j &lt;&#x3D; n;j++)&amp;#123;
            printf(&quot;%lld &quot;,ans.a[i][j]);
        &amp;#125;
        printf(&quot;\n&quot;);
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC18"><span class="toc-number">3.2.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
#define int ll
const int maxn &#x3D; 1e5+50;
struct tree&amp;#123;
    int l, r;
    int pre, add;
&amp;#125;t[4 * maxn];
int a[maxn];
inline void build(int p, int l, int r)&amp;#123;
    t[p].l &#x3D; l;
    t[p].r &#x3D; r;
    if(l &#x3D;&#x3D; r)&amp;#123;
        t[p].pre &#x3D; a[l];
        return;
    &amp;#125;
    int mid &#x3D; l + r &gt;&gt; 1;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].pre &#x3D; t[p*2].pre + t[p * 2 + 1].pre;
&amp;#125;
inline void spread(int p)&amp;#123;
    if(t[p].add)&amp;#123;
        t[p*2].pre +&#x3D; t[p].add * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].pre +&#x3D; t[p].add * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].add +&#x3D; t[p].add;
        t[p * 2 + 1].add +&#x3D; t[p].add;
        t[p].add &#x3D; 0;
    &amp;#125;
&amp;#125;
inline void change(int p, int l, int r, int num)&amp;#123;
    if(l &lt;&#x3D; t[p].l &amp;&amp; r &gt;&#x3D; t[p].r)&amp;#123;
        t[p].pre +&#x3D; (ll)num * (t[p].r - t[p].l + 1);
        t[p].add +&#x3D; num;
        return;
    &amp;#125;
    spread(p);
    int mid &#x3D; t[p].l + t[p].r &gt;&gt; 1;
    if(l &lt;&#x3D; mid) change(p * 2, l, r, num);
    if(r &gt; mid) change(p * 2 + 1, l, r, num);
    t[p].pre &#x3D; t[p * 2].pre + t[p * 2 + 1].pre;
&amp;#125;
inline int search(int p, int l, int r)&amp;#123;
    if(l &lt;&#x3D; t[p].l &amp;&amp; r &gt;&#x3D; t[p].r) return t[p].pre;
    spread(p);
    int mid &#x3D; t[p].l + t[p].r &gt;&gt; 1;
    int ans &#x3D; 0;
    if(l &lt;&#x3D; mid) ans +&#x3D; search(p * 2, l, r);
    if(r &gt; mid) ans +&#x3D; search(p * 2 + 1, l , r);
    return ans;
&amp;#125;
signed main(void)&amp;#123;
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) cin&gt;&gt;a[i];
    build(1, 1, n);
    for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&amp;#123;
        int op;
        cin&gt;&gt;op;
        int l, r, num;
        if(op &#x3D;&#x3D; 1)&amp;#123;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;num;
            change(1, l, r, num);
        &amp;#125;else&amp;#123;
            cin&gt;&gt;l&gt;&gt;r;
            cout&lt;&lt;(search(1, l, r));
            puts(&quot;&quot;);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ST%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">ST表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC19"><span class="toc-number">3.4.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn &#x3D; 1e5 + 5;
int f[maxn][21];
int lg[maxn];
inline void init(int n)&amp;#123;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        lg[i] &#x3D; lg[i-1] + (1 &lt;&lt; lg[i-1] &#x3D;&#x3D; i);
    &amp;#125;
    for(int j &#x3D; 1;j &lt;&#x3D; 21;j++)&amp;#123;
        for(int i &#x3D; 1;i + (1 &lt;&lt; j) - 1 &lt;&#x3D; n;i++)&amp;#123;
            f[i][j] &#x3D; max(f[i][j-1], f[i + (1 &lt;&lt; (j - 1))][j-1]);
        &amp;#125;
    &amp;#125;
&amp;#125;
inline int query(int l, int r)&amp;#123;
    int mid &#x3D; lg[r - l + 1] - 1;
    return max(f[l][mid], f[r - (1 &lt;&lt; mid) + 1][mid]);
&amp;#125;
signed main(void)&amp;#123;
    int n, m;
    scanf(&quot;%d %d&quot;,&amp;n, &amp;m);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)scanf(&quot;%d&quot;,&amp;f[i][0]);
    init(n);
    for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&amp;#123;
        int l, r;
        scanf(&quot;%d %d&quot;,&amp;l, &amp;r);
        printf(&quot;%d\n&quot;,query(l,r));
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">Trie树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC20"><span class="toc-number">3.6.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
#include&lt;iostream&gt;
using namespace std;
const int maxn &#x3D; 1e5;
struct node&amp;#123;
    int son[26];
&amp;#125;trie[maxn];
int cnt, root[maxn];
void insert(string str, int id)&amp;#123;
    int now &#x3D; 0;
    int l &#x3D; str.length();
    for(int i &#x3D; 0;i &lt; l;i++)&amp;#123;
        if(trie[now].son[str[i]-&amp;#x27;a&amp;#x27;] &#x3D;&#x3D; 0)&amp;#123;
            trie[now].son[str[i]-&amp;#x27;a&amp;#x27;] &#x3D; ++cnt;&#x2F;&#x2F;动态开点
        &amp;#125;
        now &#x3D; trie[now].son[str[i] - &amp;#x27;a&amp;#x27;];
    &amp;#125;
    root[now] &#x3D; id;
&amp;#125;
int search(string str)&amp;#123;
    int now &#x3D; 0;
    int l &#x3D; str.length();
    for(int i &#x3D; 0;i &lt; l;i++)&amp;#123;
        now &#x3D; trie[now].son[str[i] - &amp;#x27;a&amp;#x27;];
        if(now &#x3D;&#x3D; 0) return 0;
    &amp;#125;
    return root[now];
&amp;#125;
int main(void)&amp;#123;
    int n;
    cin&gt;&gt;n;
    string str;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        cin&gt;&gt;str;
        insert(str,i);
    &amp;#125;
    cin&gt;&gt;n;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        cin&gt;&gt;str;
        cout&lt;&lt;search(str)&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91"><span class="toc-number">3.7.</span> <span class="toc-text">主席树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC21"><span class="toc-number">3.8.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn &#x3D; 2e5 + 5;
struct Node&amp;#123;
    int l, r, sum;
&amp;#125;hjt[maxn*40];
int cnt, root[maxn];
int num[maxn];
vector&lt;int&gt; v;

int getid(int x)&amp;#123;
    return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;
&amp;#125;

void insert(int l, int r, int pre, int &amp;now, int p)&amp;#123;
    hjt[++cnt] &#x3D; hjt[pre];
    now &#x3D; cnt;
    hjt[now].sum++;
    if(l &#x3D;&#x3D; r) return;
    int mid &#x3D; (l + r) &gt;&gt; 1;
    if(p &lt;&#x3D; mid)&amp;#123;
        insert(l, mid, hjt[pre].l, hjt[now].l, p);
    &amp;#125;else&amp;#123;
        insert(mid + 1, r, hjt[pre].r, hjt[now].r, p);
    &amp;#125;
&amp;#125;

int query(int l, int r, int L, int R, int k)&amp;#123;
    if(l &#x3D;&#x3D; r) return l;
    int mid &#x3D; (l + r) &gt;&gt; 1;
    int temp &#x3D; hjt[hjt[R].l].sum - hjt[hjt[L].l].sum;
    if(k &lt;&#x3D; temp)&amp;#123;
        return query(l, mid, hjt[L].l, hjt[R].l, k);
    &amp;#125;else&amp;#123;
        return query(mid + 1, r, hjt[L].r, hjt[R].r, k - temp);
    &amp;#125;
&amp;#125;

int main(void)&amp;#123; 
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        cin&gt;&gt;num[i];
        v.push_back(num[i]);
    &amp;#125;
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(),v.end()), v.end());
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&amp;#123;
        
        insert(1, n, root[i-1], root[i], getid(num[i]));
    &amp;#125;
    for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&amp;#123;
        int l, r, k;
        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
        cout&lt;&lt;v[query(1, n, root[l-1], root[r], k) - 1]&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC22"><span class="toc-number">3.10.</span> <span class="toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lowbit(x) x &amp; -x
#define ll long long
const int maxn &#x3D; 5e5 + 10;
ll t[maxn];
inline void change(int p, int pos, int n)&amp;#123;
    for(;pos &lt;&#x3D; n;pos +&#x3D; lowbit(pos))&amp;#123;
        t[pos] +&#x3D; p;
    &amp;#125;
&amp;#125;
inline void update(int l, int r, int p, int n)&amp;#123;
    change(p, l, n);
    change(-p, r+1, n);
&amp;#125;
inline ll search(int pos)&amp;#123;
    ll sum &#x3D; 0;
    for(;pos;pos -&#x3D; lowbit(pos))&amp;#123;
        sum +&#x3D; t[pos];
    &amp;#125;
    return sum;
&amp;#125;
inline ll get_ans1(int l, int r)&amp;#123;
    return search(r) - search(l-1);
&amp;#125;
inline ll get_ans2(int pos)&amp;#123;
    ll ans &#x3D; 0;
    for(;pos;pos -&#x3D; lowbit(pos)) ans+&#x3D; t[pos];
    return ans;
&amp;#125;
signed main(void)&amp;#123;
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;
    ll num;
    ll last;
    cin&gt;&gt;last;
    change(last, 1, n);
    for(int i &#x3D; 2;i &lt;&#x3D; n;i++)&amp;#123;
        cin&gt;&gt;num;
        change(num - last, i, n);
        last &#x3D; num;
    &amp;#125;
    for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&amp;#123;
        int ord;
        cin&gt;&gt;ord;
        if(ord &#x3D;&#x3D; 1)&amp;#123;
            int l, r;
            ll k;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
            update(l, r, k, n);
        &amp;#125;else&amp;#123;
            int pos;
            cin&gt;&gt;pos;
            cout&lt;&lt;get_ans2(pos)&lt;&lt;endl;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kmp"><span class="toc-number">4.1.</span> <span class="toc-text">kmp</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Crotes</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/algolia.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 3000);</script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    let initData = {
      el: '#waline-wrap',
      serverURL: 'https://imnerd-api-eosin.vercel.app/',
      avatar: 'monsterid',
      path: location.pathname,
      emojiCDN: '',
      emojiMaps: "",
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const waline = new Waline(initData)
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    let initData = {
      el: '#twikoo-wrap',
      envId: 'crotes-9g1gdhmrfb4da8ba',
      region: ''
    }

    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    twikoo.init(initData)
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'crotes-9g1gdhmrfb4da8ba',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Waline' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var gitcalendar = new Vue({
  el: '#gitcalendar',
  data: {
    simplemode: true,
    user: 'Crotes',
    fixed: 'fixed',
    px: 'px',
    x: '',
    y: '',
    span1: '',
    span2: '',
    month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthchange: [],
    oneyearbeforeday: '',
    thisday: '',
    amonthago: '',
    aweekago: '',
    weekdatacore: 0,
    datacore: 0,
    total: 0,
    datadate: '',
    data: [],
    positionplusdata: [],
    firstweek: [],
    lastweek: [],
    beforeweek: [],
    thisweekdatacore: 0,
    mounthbeforeday: 0,
    mounthfirstindex: 0,
    crispedges: 'crispedges',
    thisdayindex: 0,
    amonthagoindex: 0,
    amonthagoweek: [],
    firstdate: [],
    first2date: [],
    montharrbefore: [],
    monthindex: 0,
    color: ['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c']
  },
  methods: {
    selectStyle(data, event) {
      document.querySelector('.angle-wrapper').style.display = 'block'
      this.span1 = data.date;
      this.span2 = data.count;
      this.x = event.clientX - 100;
      this.y = event.clientY - 60
    },
    outStyle() {
      document.querySelector('.angle-wrapper').style.display = 'none'
    },
    thiscolor(x) {
      if (x === 0) {
        let i = parseInt(x / 2);
        return this.color[0]
      } else if (x < 2) {
        return this.color[1]
      } else if (x < 20) {
        let i = parseInt(x / 2);
        return this.color[i]
      } else {
        return this.color[9]
      }
    },
  }
});
var apiurl = 'python-github-calendar-api-ochre.vercel.app' ? 'https://python-github-calendar-api-ochre.vercel.app/api?' : 'https://githubapi.ryanchristian.dev/user/'
var githubapiurl = apiurl + gitcalendar.user;
//canvas绘图
function responsiveChart() {
  let c = document.getElementById("gitcanvas");
  if (c) {
    let cmessage = document.getElementById("gitmessage");
    let ctx = c.getContext("2d");
    c.width = document.getElementById("gitcalendarcanvasbox").offsetWidth;
    let linemaxwitdh = 0.96 * c.width / gitcalendar.data.length;
    c.height = 9 * linemaxwitdh;
    let lineminwitdh = 0.8 * linemaxwitdh;
    let setposition = {
      x: 0.02 * c.width,
      y: 0.025 * c.width
    };
    for (let week in gitcalendar.data) {
      weekdata = gitcalendar.data[week];
      for (let day in weekdata) {
        let dataitem = {
          date: "",
          count: "",
          x: 0,
          y: 0
        };
        gitcalendar.positionplusdata.push(dataitem);
        ctx.fillStyle = gitcalendar.thiscolor(weekdata[day].count);
        setposition.y = Math.round(setposition.y * 100) / 100;
        dataitem.date = weekdata[day].date;
        dataitem.count = weekdata[day].count;
        dataitem.x = setposition.x;
        dataitem.y = setposition.y;
        ctx.fillRect(setposition.x, setposition.y, lineminwitdh, lineminwitdh);
        setposition.y = setposition.y + linemaxwitdh
      };
      setposition.y = 0.025 * c.width;
      setposition.x = setposition.x + linemaxwitdh
    };
    ctx.font = "600  Arial";
    ctx.fillStyle = '#aaa';
    ctx.fillText("日", 0, 1.9 * linemaxwitdh);
    ctx.fillText("二", 0, 3.9 * linemaxwitdh);
    ctx.fillText("四", 0, 5.9 * linemaxwitdh);
    ctx.fillText("六", 0, 7.9 * linemaxwitdh);
    let monthindexlist = c.width / 24;
    for (let index in gitcalendar.monthchange) {
      ctx.fillText(gitcalendar.monthchange[index], monthindexlist, 0.7 * linemaxwitdh);
      monthindexlist = monthindexlist + c.width / 12
    };
    cmessage.onmousemove = function(event) {
      document.querySelector('.angle-wrapper').style.display = 'none'
    };
    c.onmousemove = function(event) {
      document.querySelector('.angle-wrapper').style.display = 'none'
      getMousePos(c, event);
    };

    function getMousePos(canvas, event) {
      var rect = canvas.getBoundingClientRect();
      var x = event.clientX - rect.left * (canvas.width / rect.width);
      var y = event.clientY - rect.top * (canvas.height / rect.height);
      //console.log("x:"+x+",y:"+y);
      for (let item of gitcalendar.positionplusdata) {
        let lenthx = x - item.x;
        let lenthy = y - item.y;
        //console.log(lenthx,lenthy);
        if (0 < lenthx && lenthx < lineminwitdh) {
          if (0 < lenthy && lenthy < lineminwitdh) {
            //console.log(item.date,item.count)
            document.querySelector('.angle-wrapper').style.display = 'block'
            gitcalendar.span1 = item.date;
            gitcalendar.span2 = item.count;
            gitcalendar.x = event.clientX - 100;
            gitcalendar.y = event.clientY - 60
          }
        }
        //if(0< x - item.x <lineminwitdh&&0< y - item.y <lineminwitdh){
        //console.log(item.count,item.date);
        //}
      }
    }
  }
}
//数据统计算法
function addlastmonth() {
  if (gitcalendar.thisdayindex === 0) {
    thisweekcore(52);
    thisweekcore(51);
    thisweekcore(50);
    thisweekcore(49);
    thisweekcore(48);
    gitcalendar.thisweekdatacore += gitcalendar.firstdate[6].count;
    gitcalendar.amonthago = gitcalendar.firstdate[6].date
  } else {
    thisweekcore(52);
    thisweekcore(51);
    thisweekcore(50);
    thisweekcore(49);
    thisweek2core();
    gitcalendar.amonthago = gitcalendar.first2date[gitcalendar.thisdayindex - 1].date
  }
};

function thisweek2core() {
  for (let i = gitcalendar.thisdayindex - 1; i < gitcalendar.first2date.length; i++) {
    gitcalendar.thisweekdatacore += gitcalendar.first2date[i].count
  }
};

function thisweekcore(index) {
  for (let item of gitcalendar.data[index]) {
    gitcalendar.thisweekdatacore += item.count
  }
};

function addlastweek() {
  for (let item of gitcalendar.lastweek) {
    gitcalendar.weekdatacore += item.count
  }
};

function addbeforeweek() {
  for (let i = gitcalendar.thisdayindex; i < gitcalendar.beforeweek.length; i++) {
    gitcalendar.weekdatacore += gitcalendar.beforeweek[i].count
  }
};

function addweek(data) {
  if (gitcalendar.thisdayindex === 6) {
    gitcalendar.aweekago = gitcalendar.lastweek[0].date;
    addlastweek()
  } else {
    lastweek = data.contributions[51];
    gitcalendar.aweekago = lastweek[gitcalendar.thisdayindex + 1].date;
    addlastweek();
    addbeforeweek()
  }
}

fetch(githubapiurl)
  .then(data => data.json())
  .then(data => {
    gitcalendar.data = data.contributions;
    gitcalendar.total = data.total;
    gitcalendar.first2date = gitcalendar.data[48];
    gitcalendar.firstdate = gitcalendar.data[47];
    gitcalendar.firstweek = data.contributions[0];
    gitcalendar.lastweek = data.contributions[52];
    gitcalendar.beforeweek = data.contributions[51];
    gitcalendar.thisdayindex = gitcalendar.lastweek.length - 1;
    gitcalendar.thisday = gitcalendar.lastweek[gitcalendar.thisdayindex].date;
    gitcalendar.oneyearbeforeday = gitcalendar.firstweek[0].date;
    gitcalendar.monthindex = gitcalendar.thisday.substring(5, 7) * 1;
    gitcalendar.montharrbefore = gitcalendar.month.splice(gitcalendar.monthindex, 12 - gitcalendar.monthindex);
    gitcalendar.monthchange = gitcalendar.montharrbefore.concat(gitcalendar.month);
    addweek(data);
    addlastmonth();
    responsiveChart();
  })
  .catch(function(error) {
    console.log(error);
  });

//手机版更换为svg绘制
if (document.getElementById("gitcalendarcanvasbox").offsetWidth < 500) {
  gitcalendar.simplemode = false
}

//当改变窗口大小时重新绘制canvas
window.onresize = function() {
  if (gitcalendar.simplemode) responsiveChart()
}

//解决滚动滑轮时出现的标签显示
window.onscroll = function() {
  if (document.querySelector('.angle-wrapper')) {
    document.querySelector('.angle-wrapper').style.display = 'none'
  }
};</script></div><link rel="stylesheet" href="/css/my.css"><script defer type="text/javascript" src="/js/my.js"></script><div class="aplayer no-destroy" data-id="8103073475" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})</script></div><!-- hexo injector body_end start --><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><!-- hexo injector body_end end --><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>